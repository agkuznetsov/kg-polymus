<p>Память компьютера представлена запоминающими устройствами двух принципиально разных типов: основная память (main memory), часто называемая оперативной памятью, в которой хранятся программы, выполняемые процессорами, и данные, непосредственно доступные для команд (инструкций) процесса, и внешняя память (external memory), позволяющая долговременно сохранять и перемещать в основную память и обратно команды и данные. 	Основным отличием внешней памяти от основной является возможность долговременного сохранения содержимого после отключения электропитания (долговременность хранения, non-volatile memory). Традиционная основная память этим свойством не обладает и поэтому является недолговечной (volatile memory).</p><p>Вторым важным различием внешней от основной памяти являются стоимость и объем. Традиционно в расчете на единицу объема памяти внешняя память существенно дешевле основной памяти (от 10 до 100 раз). Поэтому в стандартных компьютерах объем доступной внешней памяти обычно значительно превышает объем доступной основной памяти. Внешняя память называется внешней потому, что если обращения к основной памяти производятся компьютером при выполнении соответствующих инструкций (например, команд загрузки регистра из основной памяти - load и записи содержимого регистра в основную память - store), то внешняя память управляется некоторым внешним по отношению к компьютеру устройством, и для выполнения операции обмена с внешней памятью требуется выполнение в процессоре ряда специальных команд.</p><p>В первые годы развития вычислительной техники (конец сороковых - пятидесятые годы ХХ-го века) использовались два вида устройств внешней памяти: магнитные ленты и магнитные барабаны. Емкость магнитных лент была достаточно велика, но по своей природе они обеспечивали только последовательный доступ к данным. Емкость магнитной ленты пропорциональна ее длине. Чтобы получить доступ к требуемой порции данных, нужно в среднем перемотать половину ее длины. Но чисто механическую операцию перемотки нельзя выполнить очень быстро. Поэтому быстрый произвольный доступ к данным на магнитной ленте, очевидно, невозможен.</p><p>Магнитный барабан представлял собой массивный металлический цилиндр с намагниченной внешней поверхностью и неподвижным пакетом магнитных головок. Такие устройства обеспечивали возможность достаточно быстрого произвольного доступа к данным, но позволяли сохранять сравнительно небольшой объем хранения данных. Быстрый произвольный доступ осуществлялся благодаря высокой скорости вращения барабана и наличию отдельной головки на каждую дорожку магнитной поверхности; ограниченность объема была обусловлена наличием всего одной магнитной поверхности.</p><p>В те времена компьютеры, в основном, использовали для численных расчетов. Указанные ограничения не очень существенны для таких задач. Прежде всего, для получения требуемых результатов серьезные вычислительные программы должны проработать достаточно долгое время (недели, месяцы и даже, может быть, годы). Наличие гарантий надежности со стороны производителей аппаратных компьютерных средств не избавляет программистов от необходимости использования программного сохранения частичных результатов вычислений, чтобы при возникновении непредвиденных сбоев аппаратуры можно было продолжить выполнение расчетов с некоторой контрольной точки. Для сохранения промежуточных результатов идеально подходят магнитные ленты: при выполнении процедуры установки контрольной точки данные последовательно сбрасываются на ленту, а при необходимости перезапуска от сохраненной контрольной точки данные также последовательно с ленты считываются.</p><p>Вторая традиционная потребность численных программистов - максимально большой объем основной памяти. Большая основная память требуется, во-первых, для того, чтобы обеспечить программе быстрый доступ к большому количеству обрабатываемых данных. Во-вторых, сложные вычислительные программы сами могут иметь большой объем. Поскольку объем реально доступной в ЭВМ основной памяти всегда являлся недостаточным для удовлетворения текущих потребностей вычислений, требовалась быстрая внешняя память для организации виртуальной памяти. Не вдаваясь в детали организации этих механизмов программного расширения основной памяти, заметим, что для этого идеально подходили магнитные барабаны. Они обеспечивают быстрый доступ к внешней памяти, а для расширения основной памяти одной программы (сложные вычислительные программы, как правило, выполняются на компьютере в одиночку) большой объем внешней памяти не требуется.</p><p>Далее заметим, что, даже если программа должна обработать (или произвести) большой объем информации, при программировании можно продумать расположение этой информации во внешней памяти, чтобы программа работала как можно быстрее. Развитая поддержка работы с внешней памятью со стороны общесистемных программных средств не обязательна, а иногда и вредна, поскольку приводит к дополнительным накладным расходам аппаратных ресурсов.</p><p>Однако расширение сферы применения вычислительной техники вызвало появление в 60-е годы ХХ-го века информационных систем, в которых объем постоянно хранимых данных определяется спецификой бизнес-приложения, а потребность в текущих данных - пользователем приложения, одних только магнитных барабанов и лент недостаточно. Емкость магнитного барабана просто не позволяет долговременно хранить данные большого объема. Что же касается лент, то представьте себе состояние человека, который, стоя у билетной кассы, должен дождаться полной перемотки магнитной ленты. Естественным требованием к таким системам является обеспечение высокой средней скорости выполнения операций при наличии больших объемов данных.</p><p>Именно требования к устройствам внешней памяти со стороны бизнес-приложений вызвали появление устройств внешней памяти со съемными пакетами магнитных дисков и подвижными головками чтения/записи, что явилось революцией в истории вычислительной техники. Соответствующую технологию разработала и внедрила компания IBM в конце 1950-х - начале 1960-х гг. Эти устройства памяти обладали существенно большей емкостью, чем магнитные барабаны (за счет наличия нескольких магнитных поверхностей), обеспечивали удовлетворительную скорость доступа к данным в режиме произвольной выборки, а возможность смены дискового пакета на устройстве позволяла иметь архив данных практически неограниченного объема.</p><p>	Появление персональных компьютеров привело к созданию, так называемых, жестких дисков. Жесткий диск - это устройство внешней памяти, состоящей из магнитных дисков небольшого размера (около 9 см. в диаметре), который размещают в герметически закрытой коробке.</p><p>Магнитные диски представляют собой пакеты магнитных пластин (поверхностей), между которыми на одном рычаге двигается пакет магнитных головок (рис. 1). Шаг движения пакета головок является дискретным, и каждому положению пакета головок логически соответствует цилиндр пакета магнитных дисков. На каждой поверхности цилиндр «высекает» дорожку, так что каждая поверхность содержит число дорожек, равное числу цилиндров. При разметке магнитного диска (специальном действии, предшествующем использованию диска) каждая дорожка размечается на одно и то же количество блоков; таким образом, предельная емкость каждого блока составляет одно и то же число байтов. Для произведения обмена с магнитным диском на уровне аппаратуры нужно указать номер цилиндра, номер поверхности, номер блока на соответствующей дорожке и число байтов, которое нужно записать или прочитать от начала этого блока.</p><p>Рис. 1. Грубая схема дискового устройства памяти с подвижными головками</p><p>При выполнении обмена с диском аппаратура выполняет три основных действия: подвод головок к нужному цилиндру (обозначим время выполнения этого действия как tпг), поиск на дорожке нужного блока (время выполнения - tпб) и собственно обмен с этим блоком (время выполнения - tоб). Как правило, tпг&gt;&gt;tпб&gt;&gt;tоб, потому что подвод головок - это механическое действие, причем в среднем нужно переместить головки на расстояние, равное половине радиуса поверхности, а скорость передвижения головок не может быть слишком большой по физическим соображениям. Поиск блока на дорожке требует прокручивания пакета магнитных дисков в среднем на половину длины внешней окружности; скорость вращения диска может быть существенно больше скорости движения головок, но она тоже ограничена законами физики. Для выполнения же обмена нужно прокрутить пакет дисков всего лишь на угловое расстояние, соответствующее размеру блока. Таким образом, из всех этих действий в среднем наибольшее время занимает первое, и поэтому существенный выигрыш в суммарном времени обмена при считывании или записи только части блока получить практически невозможно.</p><p>Первое устройство хранения данных с произвольным доступом, позднее названное жестким диском (Hard Disc Drive, HDD), или винчестером, было выпущено компанией IBM в 1956 году. Устройство имело емкость всего 5 Мбайт, а данные записывались на 50 дисков диаметром 24 дюйма, вращавшихся со скоростью 1200 об./мин. Среднее время доступа равнялось одной секунде, а плотность записи составляла всего 2 Кбит/кв.дюйм. Размеры устройства были сравнимы с размером двух домашних холодильников, стоимость же его составляла 50 тыс. долл. С этого гиганта началось бурное развитие технологии магнитной записи на диски. Если сначала плотность записи была равна 2 Кбит/кв.дюйм, то в настоящее время она уже составляет порядка 70 Гбит/кв.дюйм у коммерческих продуктов и превышает 100 Гбит/кв.дюйм у лабораторных образцов жестких дисков. Таким образом, на протяжении многих лет плотность записи информации на диск увеличивалась на 100% ежегодно (рис. 1). Однако в последние несколько лет темпы роста плотности записи сократились и составляют теперь около 60% ежегодно.</p><p>Вместе с ростом плотности записи меняются и другие характеристики жестких дисков. В частности, если говорить о геометрическом возрастании плотности записи, то в такой же пропорции увеличивается и максимальная емкость дисков, а кроме того, уменьшается и стоимость дисков в расчете на один гигабайт емкости.</p><p>	В настоящее время широкое распространения получают твердотельные диски или дики на флэш-памяти. Это устройство внешней памяти на электронных микросхемах, у которых нет механических частей. Поэтому они надежнее традиционных дисковых подсистем, но имеют ограниченный ресурс по числу циклов перезаписи. Не вдаваясь в подробности, отметим, что чтение и запись на флэш-диск происходит порциями: страницами и блоками. Скорость доступа к блоку не зависит от его расположения во флэш-памяти. Далее для простоты изложения будем вести рассуждения для внешней памяти на традиционных дисках.</p><p>С появлением магнитных дисков началась история систем управления данными во внешней памяти. До этого каждая прикладная программа, которой требовалось хранить данные во внешней памяти, сама определяла расположение каждой порции данных на магнитной ленте или барабане и выполняла обмены между основной и внешней памятью с помощью программно-аппаратных средств низкого уровня (машинных команд или вызовов соответствующих программ операционной системы). Такой режим работы не позволял или очень затруднял поддержку на одном внешнем носителе нескольких архивов долговременно хранимой информации. Кроме того, каждой прикладной программе приходилось решать проблемы именования частей данных и структуризации данных во внешней памяти.</p><p>Архитектура систем внешней памяти на дисках</p><p>Здесь мы рассмотрим организацию и основные функции внешней памяти на дисках, используемой системами хранения и доступа к данным. На дисках потому, что это наиболее распространенный и широко используемый вид внешней памяти сегодня. Хотя современные диски фактически дисками уже не являются (в них нет механических частей), но принцип их работы напоминает работу диска: запись и чтение данных в таких устройствах происходит блоками.</p><p>Серверно-ориентированный системы</p><p>Традиционно в архитектуре вычислителей предполагалось подключение внешней памяти непосредственно к самому вычислителю, отдельному серверу. (рис. )</p><p>В отдельных случаях с целью повышения надежности внешнюю </p><p>[w:drawing]</p><p>память подключали к двум серверам, но в каждый момент времени работал только один из них. Второй вступал в работу только, если первый выходил из строя. Все другие компьютеры сети получали доступ к данным на дисках сервера только через обращение к этому серверу. Такая архитектура получила название серверно-ориентированной архитектурой. В этой архитектуре сервер и устройства внешней памяти соединяются быстрым, но коротким каналом передачи данных.</p><p>Выход из строя сервера означает недоступность для других компьютеров доступа к данным, хранящимся во внешней памяти сервера. Это не приемлемо для целого ряда приложений, например, банковской сферы, где данные о клиенте должны быть доступны 24 часа 7 дней в неделю.  Хотя плотность записи на магнитные диски и ленты постоянно увеличивается, объёмы данных, которые необходимо хранить, растут быстрее.</p><p>Однако число устройств внешней памяти (везде далее дисков), которое можно подключить к серверу, ограничено геометрическими размерами самого сервера. Кроме этого, как уже было отмечено, кабель, соединяющий диск с сервером имеет ограниченную длину (максимум 25 м.). Это означает, что объем хранилища, образуемого дисками, подключенными к серверу, ограничен.</p><p>[w:drawing]</p><p>Так же такая архитектура не позволяет динамически перераспределять доступное пространство хранилища. Например, если на вышеприведенном рисунке, дисковое пространство у сервера 2 переполнится, то он не сможет быстро воспользоваться свободным дисковым пространством на сервера 1 или сервере 3. Так же в больших организациях сервера с дисками бывают разбросаны по всему зданию, что существенно затрудняет контроль доступа к данным на дисках.</p><p> Сети хранилищ данных</p><p>Сети хранилищ данных позволяют устранить недостатки, присущие системам хранения с серверно-ориентированной архитектурой. Организация сети хранилищ данных (далее просто хранилищ) показана на рисунке ниже. Основывая ее идея состоит в том, чтобы заменить отдельные кабели, соединяющие устройство внешней памяти с сервером на сеть, которая используется исключительно в целях обмена данными между компьютерами в локальной сети и устройствами внешней памяти.</p><p>[w:drawing]</p><p>Эта сеть не зависит от работоспособности какого-либо компьютера, она полностью независима от них. Сервера могут свободно разделять доступ к одному и тому же сетевому хранилищу, не затрагивая работу другого сервера.  В центре такой архитектуры становится сеть хранилищ данных, сервера являются лишь средствами обработки данных. Такая архитектура предполагает агрегирование множества мелких жестких дисков в одну большую дисковую подсистему. Современные дисковые подсистемы достигают объемов в несколько пета байт. Сеть хранилищ позволяет любому компьютеру в сети обращаться к любой дисковой подсистеме. Это позволяет динамично перераспределять дисковое пространство доступное разным приложениям. Сети хранилищ данных (СХД) становятся неотъемлемым компонентом современных центров обработки данных, высокопроизводительных вычислительных установок.</p><p>Дисковые подсистемы</p><p>Условно дисковые подсистемы (ДПС) можно разделить на два класса: ДПС с контроллером и ДПС без контролера. ДПС без контроллера или, как еще называют этот вид ДПС -  Пакет Дисков (Just a Bunch Of Dicks), представляет собой набор из 8 - 16 жестких дисков, упакованных в единый корпус с общим блоком питаний. ДПС Пакет Дисков легче обслуживать и использовать, если независимо иметь дело с 16 жесткими дисками.</p><p>Основой ДПС второго вида является дисковый сервер, называемый контроллер. У этого контроллера есть несколько портов (сетевых адаптеров) - точек подключения к сети. К этим портам подключаются сервера приложений с помощью обычных сетевых интерфейсов и систем передачи данных типа Ethernet, Small Computer System Interface (SCSI), Fibre Channel. Несколько жёстких дисков также подключают по внутренней шине к этому контроллеру. (рисунок)</p><p>Таким образом контроллер является посредником между серверами приложений и своей внутренней дисковой памятью.  Внутренняя структура дисковой подсистемы полностью скрыта от серверов приложений. Контроллер, точнее его программное обсечение, является интеллектуальным центром дисковой подсистемы.  Благодаря контроллеру удается добиться высоких показателей в скорости доступа к данным, отказоустойчивости дисковой подсистемы.</p><p>[w:drawing]</p><p>Контроллер, точнее его программное обеспечение, позволяет реализовывать разнообразные сервисы, такие как, доступность данных во внешней памяти в случае выхода из строя одного или нескольких физических дисков ДПС, реализовать архивное копирование данных, восстановление данных, синхронизацию данных, если одни и те же данные располагают на разных, связанных между собой, ДПС.</p><p>Такая ДПС оснащена внутренней кэш памятью, которая позволяет существенно повысить скорости записи на диски. Сервер приложения посылает время от времени ДПС блоки данных со скоростью, которая выше скорости записи на физический диск. Чтобы сгладить различие в скорости поступления блоков от сервера и скорости записи на физический диск, контроллер ДПС оснащают кэш-памятью, у которой скорость записи/чтения не ниже чем скорость поступления блоков данных от сервера приложений. Контроллер забирает блоки из кэш-памяти и записывает их на физические диски со скоростью доступной физическому диску.</p><p>	У каждого физического диска есть свой кэш не большого размера, который позволяет контроллеру записать/считать блок данных в локальный кэш диска и перейти к следующей операции, а физический диск, уже с доступной ему скоростью, запишет данные на свои пластины.</p><p>Методы надежного хранения данных во внешней памяти</p><p>Надежность хранения данных в ДПС, или как еще говорят, доступность данных во внешней памяти обеспечивают либо за счет резервирования дисков в ДПС в сочетании с дублированием одних и тех же данных на разных дисках одной и той же ДПС. Для этого контроллер ДПС реализует сервис, называемый Redundant Array of Independent Disks (RAID) в сочетании с горячим резервированием дисков.</p><p>Идея RAID дисковых массивов состоит в том, что при записи данных в ДПС данные дублируются на нескольких дисках. Применяются разные способы дублирования. Идея горячего резервирования состоит в том, что часть дисков ДПС выводится в резерв и в работе ДПС не используется. Однако если хоть один из работающих дисков выходит из строя, контроллер:</p><p>выводит вышедший из строя диск из состава используемых дисков;</p><p>вводит в работу один из дисков, находившихся в резерве;</p><p>за счет наличия копий данных, которые были расположены на испорченном диске, контроллер инициирует восстановление этих данных на диске, выведенном из резерва;</p><p>информирует администратора о вышедшем из строя диске.</p><p>Администратор сам или с помощью дежурного инженера вынимает испорченный диск из ДПС и заменяет его новым. После этого контроллер фиксирует новый диск как резервный.</p><p>RAID массивы</p><p>RAID контроллер реализует широкий спектр сервисов, недоступных для ДПС Пакет дисков. Его сервисы нацелены на повышение скорости операций чтения/записи на диски и повышение отказоустойчивости ДПС за счет избыточности в хранимых данных. Избыточность в хранимых данных выражается в том, что, либо хранимые данные разбивают на блоки, каждый из которых дублируют и располагают на разных физических дисках, либо хранят некоторую дополнительную информацию о блоке, которая позволяет восстановить данные блока в случае отказа диска.</p><p>Увеличить скорость чтения/записи на отдельный физический диск не представляется возможным. Ограничения скорости операций чтения/записи на физический диск есть следствия законов физики. Однако если в кэш памяти ДПС есть несколько блоков данных, ожидающих записи, то можно выполнять операцию записи блока последовательно, блок за блоком. А, можно выполнять операцию запись/чтение блоков данных параллельно сразу для нескольких блоков на разные физические диски. В последнем случае, скорость чтения/записи блока возрастет прямо пропорционально числу физических дисков, участвующих в такой операции. При этом есть режимы работы контроллера, когда операции чтения/записи нескольких блоков только распараллеливают, а есть режимы, когда блоки данных еще и дублируют для последующего восстановления в случае выхода из строя диска.</p><p>Для реализации упомянутых выше режимов контроллер «объединяет» физические диски в один виртуальный диск большого объема. Пользователи и приложения такой ДПС не видят отдельных физических дисков, а видят только один диск большого объема.  Виртуальный диск может быть не один и для каждого виртуального диска контроллер может выделить свой пул физических дисков для горячего резервирования. Все описанные выше манипуляции, связанные с формированием виртуальных дисков, горячим резервированием не видимы для серверов с приложениями для обработки данных. RAID контроллер управляет распределением блоков данных по физическим дискам, физическими дисками при горячем резервировании.</p><p>[w:drawing]</p><p>[w:drawing]</p><p>Рисунки поясняют сказанное.</p><p>С 1987 годе, когда впервые появились RAID контроллеры, было предложено более десятка разных режимов работы RAID контроллера, или как еще говорят, RAID схем. Однако на практике сегодня используют не более шести.</p><p>Моментальное копирование и Зеркалирование</p><p>Сервис моментального копирования требуется везде где приходиться сталкиваться с большими объемами данных в несколько терабайт, например, при архивации больших массивов данных, необходимости быстро сохранить данные с большого числа датчиков или каких-то приборов.</p><p>Идея сервиса моментального копирования состоит в следующем. Сервер приложения посылает несколько терабайт данных ДПС. ДПС очень быстро сообщает серверу приложений, что данные скопированы. После этого этот или другой сервер приложений может использовать эти данные. На самом деле операция записи такого объема данных занимает существенно большее время.</p><p>	Такого эффекта достигают за счет того, что контроллер, при поступлении команды на моментальное копирование данных, выделяет сразу несколько дисков для записи данных из кэш-памяти и для формирования как минимум одной их копии, которую называют зеркалом. Запись оригинальных данных и формирование зеркала из кэш-памяти контроллера происходит в параллель. При этом контроллер следит, чтобы пока оригинальный блок данных не скопирован в зеркало в него не могли внести изменений. Есть много вариантов этого сервиса, например, записывать только те блоки, в которых были сделаны какие-либо изменения.</p><p>Моментальное копирование хорошо подходит для сохранения работоспособности системы в случаях ошибок внутри самой ДПС, либо отдельного приложения, которое работает с ДПС. Однако оно бесполезно, если вышла из строя сама ДПС. Например, отключение электропитания, разрушение линии связи, разного рода аварий, пожара. В случае пожара данные скорее всего будут разрушены и восстановить их будет нельзя. Удаленное зеркалирование предназначено именно для защиты от таких случаев.</p><p>Современные ДПС могут копирования свои данные на другую ДПС, удаленную от оригинальной на большое расстояние. Операция удалённого зеркалирования невидима для сервера приложений и не затрагивает его ресурсы. В ней задействованы ресурсы двух ДПС и канал связи между ними. Это означает, что скорость работы этих ДПС, с точки зрения работающих с ними приложений, может снизиться, так как часть их ресурсов будет использована для операции удаленного зеркалирования.</p><p>	Различают синхронное и асинхронное зеркалирование. В первом случае первичная ДПС не вышлет подтверждение серверу приложений о том, что операция копирования завершена, до тех пор, пока она не сформирует зеркало во вторичной ДПС.  Вторичная ДПС выполняет у себя операцию моментального копирования полученных данных и подтверждает выполнение операции копирования первичной ДПС, которая в свою очередь шлет подтверждение о завершении копирования серверу приложения.</p><p>При асинхронном зеркалировании, первичная ДПС сразу подтверждает серверу приложений о завершении формирования копии, и лишь потом начинает формировать зеркало во вторичной ДПС. Межу этими двумя схемами есть одно принципиальное различие. Если при асинхронной схеме данные в первичной ДПС будут изменены приложением, то это изменение может быть не отражено во вторичной. Мы получим рассогласование данных или, как еще говорят, данные станут не консистентны.</p><p>Обеспечение консистентности данных</p><p>Для того чтобы избежать рассогласованности данных используют третью ДПС, аппарат временных меток, механизм линеаризации записи, который обеспечивает сохранение порядка записи блоков данных на диск.</p><p>Использование третьей ДПС позволяет сделать следующее. Первые две ДПС выполняют синхронное зеркалирование и тем самым обеспечивают согласованность хранимых у них записей, а формирование зеркала в третьей ДПС происходит по асинхронной схеме. Любые изменения в данных в первичной ДПС вызовет синхронные изменения во вторичной, которая позаботиться о внесении изменений в третьей ДПС. Самое главное, что при такой схеме работа приложения не будет тормозиться формированием зеркала в третьей ДПС.</p><p>Аппарат временных меток позволяет решить следующую проблему. Приложения такие как Системы Управления Базами Данных (СУБД) обычно распределяют хранимые данные по нескольким виртуальным дискам.  В зависимости от объема данных и требований к производительности СУБД данные могут быть распределены даже по разным ДПС. Эти данные могут быть использованы разными приложениями на разных серверах, как в случае с Web-серверами. При работе с такого типа данными надо позаботиться о консистентности данных при их зеркалировании, чтобы в случае аварийной ситуации данные можно было бы корректно восстановить.</p><p>Например, если СУБД, работая с несколькими виртуальными дисками будет использовать операцию моментального копирования, то все данные будут копироваться почти в одно и то же время. Однако «почти» не означает в одно и то же время. СУБД будет писать все время одну и ту же временную метку на свои виртуальные диски. Однако при моментальном копировании и удаленном зеркалировании могут возникнуть расхождения во временных метках. Если при восстановлении данных не все 100% записей будут иметь одну и ту же временную метку, то операция восстановления будет прекращена.</p><p>Для решения этой проблемы применяют механизм групп консистентности. Если при запросе на моментальное копирование будет указано, что создаваемая копия является группой консистентности, то все блоки этой группы на виртуальном диске или даже разных виртуальных дисках в разных ДПС будут иметь одну и ту же временную метку.</p><p>Особый случай консистентности - консистентность по записи, которая означает строгое сохранение порядка записи блоков. Может оказаться так, что при моментальном копировании на первичном диске этот порядок будет один, но при удаленном асинхронном зеркалировании он будет нарушен. Например, если данные расположены на разных виртуальных дисках, то при удаленном архивировании порядок записи в архиве может быть нарушен. Включение механизма консистентности по порядку записи гарантирует сохранение порядка записи как на первичном диске.</p><p>Файловые системы</p><p>Историческим шагом в развитии систем хранения и доступа к данным явилось появление систем управления файлами. С точки зрения пользователя, файл - это область внешней памяти с уникальным именем и определенной структурой, в которую можно записывать и из которой можно считывать данные. Правила именования файлов, способ доступа к данным, хранящимся в файле, и структура этих данных зависят от конкретной системы управления файлами и, возможно, от типа файла. Система управления файлами берет на себя распределение внешней памяти, отображение имен файлов в соответствующие адреса внешней памяти и обеспечение доступа к данным.  В случае дисковой внешней памяти, она является частью операционной системы, посредником между контроллером дисковой подсистемы и операционной системы компьютера.</p><p>Прежде, чем приступить к рассмотрению организации файловых систем и их истории, надо сделать две оговорки. Во-первых, есть определенная терминологическая путаница. Термин файловая система (file system) используется для обозначения как программной системы, управляющей файлами, так и архива файлов, хранящегося во внешней памяти. Первая, как правило, является одной из подсистем операционной системы. Было бы лучше в первом случае использовать термин система управления файлами, оставив за термином файловая система только второе значение. Однако принятая практика вынуждает использовать термин файловая система в обоих смыслах. Точный смысл термина должен быть понятен из контекста. (Аналогичная путаница возникает при некорректном использовании терминов база данных и система управления базами данных. Рекомендуется строго различать эти термины) Во-вторых, здесь мы ограничимся описанием основных свойств так называемых традиционных файловых систем, не затрагивая многих особенностей современных файловых систем.</p><p>Первая развитая файловая система была разработана специалистами IBM в середине 60-х гг. для в компьютеров System/360. В этой системе впервые появились контроллеры управления дисковыми устройствами. Контроллеры обеспечивали возможность обмена с дисковыми устройствами порциями данных произвольного размера, а также индексный доступ к записям файлов, и эти функции контроллеров активно использовались в файловой системе ОS/360.</p><p>Файловая система ОS/360 оказала огромное влияние на дальнейшее развитие файловых систем, дала разработчикам файловых систем уникальный опыт использования дисковых устройств с подвижными головками.</p><p>Структуры файлов</p><p>Практически во всех современных компьютерах основными устройствами внешней памяти являются магнитные диски с подвижными головками, и именно они служат для хранения файлов. Как отмечалось ранее, аппаратура магнитных дисков допускает выполнение обмена с дисками блоками - порциями данных определенного размера. Однако из-за особенностей дисковых подсистем возможность обмениваться с магнитными дисками порциями, размеры которых меньше размера целого блока, в настоящее время отсутствует. Это связано с двумя обстоятельствами.</p><p>Во-первых, как уже отмечалось, считывание или запись только части блока не приводит к существенному выигрышу в суммарном времени обмена. Во-вторых, для работы с частями блоков файловая система должна обеспечить буферы основной памяти соответствующего размера, что существенно усложняет распределение основной памяти. Алгоритмы распределения памяти порциями произвольного размера плохи тем, что любой из них рано или поздно приводит к внешней фрагментации памяти. В памяти образуется большое число мелких свободных фрагментов. Их совокупный размер может быть больше размера любого требуемого буфера, но его можно выделить, только если произвести сжатие памяти, т. е. подвижку всех занятых фрагментов таким образом, чтобы они располагались вплотную один к другому. Во время выполнения операции сжатия памяти нужно приостановить выполнение обменов, а сама эта операция занимает много времени.</p><p>Поэтому во всех современных файловых системах явно или неявно выделяется уровень, обеспечивающий работу с базовыми файлами, которые представляют собой наборы блоков, последовательно нумеруемых в адресном пространстве файла и отображаемых на физические блоки диска (рис. 2). Размер логического блока файла совпадает с размером физического блока диска или кратен ему; обычно размер логического блока выбирается равным размеру страницы виртуальной памяти, поддерживаемой аппаратурой компьютера совместно с операционной системой.</p><p>В некоторых файловых системах базовый уровень был доступен пользователю, но чаще его скрывали под некоторым более высоким уровнем, доступным для пользователя. Исторически существует два основных подхода организации файлов. При первом подходе, пользователи представляют файл как последовательность записей. Каждая запись - это последовательность байтов, имеющая постоянный или переменный размер. Можно читать или писать записи последовательно либо выбирать запись в файле по номеру.</p><p>Рис. 2. Схематичное изображение базового файла</p><p>В некоторых файловых системах допускается структуризация записей на поля и объявление указываемых полей ключами записи. В таких файловых системах можно потребовать выборку записи из файла по заданному ключу. Естественно, в этом случае файловая система поддерживает в том же (или другом, служебном) базовом файле дополнительные, невидимые пользователю, служебные структуры данных. Существуют многоключевые способы организации файлов (у одного файла объявляется несколько ключей, и можно выбирать записи по значению каждого ключа).</p><p>Второй подход, получивший распространение вместе с операционной системой UNIX, состоит в том, что любой файл представляется как непрерывная последовательность байтов. Из файла можно прочитать указанное число байтов, либо начиная с его начала, либо предварительно выполнив его позиционирование на байт с указанным номером. Аналогично можно записать указанное число байтов либо в конец файла, либо предварительно выполнив позиционирование файла. Тем не менее, заметим, что скрытым от пользователя, но существующим во всех разновидностях файловых систем ОС UNIX, является базовое блочное представление файла.</p><p>Логическая структура файловых систем и именование файлов</p><p>Во всех современных файловых системах используется иерархическое именование файлов. Для этого в структуру файловой системы вводят такой объект как каталог. Каталог - это служебный файл со специальной структурой, недоступной пользователю. Каждый каталог содержит имена других каталогов и/или файлов, хранящихся в данном каталоге. Множество имен файлов в двух разных каталогах никогда не пересекаются, т.е. не имеют общих имен. Таким свойством обладает такая математическая структура, которая называется деревом. Она похожа на дерево, повернутое кроной вниз. Таким образом, полное имя любого файла состоит из списка имен каталогов плюс имя файла в каталоге, непосредственно содержащем данный файл.  Например, если есть каталог с именем А, который содержит каталог В, который содержит каталог D, который содержит файл с именем «Этот». Тогда полное имя файла «Этот» будет А.В.D.Этот.</p><p>Иерархическое именование файлов обеспечивает несколько преимуществ, основным из которых является простая и удобная схема логической классификации файлов и генерации их имен. Можно сопоставить каталог или цепочку каталогов с пользователем, подразделением, проектом и т. д. и гарантировать уникальность имен файлов и других каталогов в этом каталоге.</p><p>Принципиальное различие между способами именования файлов в разных файловых системах состоит в том, с чего начинается эта цепочка имен. В любом случае первое имя должно соответствовать корневому каталогу файловой системы. Вопрос заключается в том, где он располагается, как выглядит имя корневого каталога и как сопоставить этому имени корневой каталог - где его искать? Есть два радикально различных подхода к выбору начала.</p><p>Во многих системах управления файлами требуется, чтобы каждый архив файлов (полное дерево каталогов) целиком располагался на одном дисковом пакете или логическом диске - разделе физического дискового пакета, логически представляемом в виде отдельного диска с помощью средств операционной системы. В этом случае полное имя файла начинается с имени дискового устройства, на котором установлен соответствующий диск. Такой способ именования использовался в файловых системах компаний IBM и DEC; очень близки к этому и файловые системы, реализованные в операционных системах семейства Windows компании Microsoft. Можно назвать такую организацию поддержкой изолированных файловых систем.</p><p>Другой крайний вариант был реализован в файловых системах операционной системы Multics (http://multicians.org/). В файловой системе Multics пользователям обеспечивалась возможность представлять всю совокупность каталогов и файлов в виде единого дерева. Полное имя файла начиналось с имени корневого каталога, и пользователь не обязан был заботиться об установке на дисковое устройство каких-либо конкретных дисков. Сама система, выполняя поиск файла по его имени, запрашивала у оператора установку необходимых дисков. Такую файловую систему можно назвать полностью централизованной.</p><p>Конечно, централизованные файловые системы во многом удобнее изолированных: система управления файлами выполняет больше рутинной работы. В частности, такая файловая система оповещает автоматически своего администратора потребности установить определенные дисковые пакеты; система обеспечивает равномерное распределение памяти на известных ей дисковых томах; возможна организация автоматического перемещения редко используемых файлов на более медленные носители внешней памяти; облегчается рутинная работа, связанная с резервным копированием данных.</p><p>Однако в таких системах возникают существенные проблемы, если требуется использовать поддерево файловой системы на другой вычислительной системе. Поскольку файлы и каталоги любого логического поддерева могут быть физически разбросаны по разным дисковым пакетам, то для такого переноса требуется специальная утилита, собирающая все объекты требуемого поддерева на одном внешнем носителе, не входящем в состав штатных устройств централизованной файловой системы. Выполнение процедуры физической сборки требует существенного времени.</p><p>Компромиссное решение было предложено в файловой системе операционной системы (ОС) UNIX. На базовом уровне в этих файловых системах поддерживаются изолированные архивы файлов. Один из таких архивов объявляется корневой файловой системой. Это делается на этапе генерации операционной системы, и после запуска операционная система «знает», на каком дисковом устройстве (физическом или логическом) располагается корневая файловая система. После запуска системы можно «под монтировать» к корневой файловой системе ряд изолированных файловых систем в одну общую файловую систему. Технически это осуществляется посредством создания в корневой файловой системе специальных пустых каталогов (точек монтирования).</p><p>Специальный системный вызов mount ОС UNIX позволяет подключить к одному из пустых каталогов корневого каталога указанного архива файлов. Выполнение такого действия приводит к «наложению» корневого каталога монтируемой файловой системы на каталог точки монтирования; корневой каталог приобретает имя каталога точки монтирования. После монтирования в общей файловой системы именование файлов происходит так же, как если бы она с самого начала была централизованной. Если учесть, что обычно монтирование файловой системы производится при выполнении стартового командного файла (запуске системы), пользователи ОС UNIX, как правило, и не задумываются о происхождении общей файловой системы. Кроме того, ОС UNIX поддерживает системный вызов unmount, «отмонитрующий» ранее под монтированный архив от общей иерархии файловой системы. Все это заметно облегчает перенос частей файловой системы на другие компьютеры.</p><p>	Сетевые файловые системы</p><p>Все что было сказано выше относится к, так называемым, локальным файловым системам, т.е. файловым системам, размещенным на дисках, подключенных к тому же компьютеру, за которым работает пользователь или приложение. Проблему доступа к файлам, расположенным на других компьютерах позволяют решить сетевые файловые системы. Сетевая файловая система позволяет пользователю за одним компьютером, подключенном к сети, получить доступ к файлам, размещенным в файловой системе другого компьютера, подключенного к той же сети.</p><p>	Первой широко распространённой сетевой файловой системой стала Network File System компании Sun Microsystems. Которая стала стандартом de facto среди Unix операционных систем. Позже компания Microsoft выпустила свою версию сетевой файловой системы - Common Internet File System (CIFS), для операционной системы Windows. CIPS была не совместима с NFS от Sun Microsystems.</p><p>	С помощью сетевой файловой системы пользователи могут разделять доступ к одному и тому же файлу. Для этого в ОС Unix администратор локальной файловой системы должен подмонтировать   к ней внешнюю файловую системы. Аналогичный механизм есть и в ОС Windows. C появлением компьютерных сетей и Интернета, за долго до появления Всемирной паутины (World Wide Web - WWW), был создан протокол FTP (File Transfer Protocol) для обмена файлами через Интернет. С помощью FTP   пользователь мог считать в локальную файловую систему своего компьютера файл из локальной файловой системы другого компьютера, к которому он имел доступ.</p><p>	С появлением WWW пользователи стали работать не с файлами, а с HTML документами.  Hyper Text Markup Language (HTML) - язык разметки документов и Hyper Text Transfer Protocol (HTTP) - протокол передачи HTML документов коренным образом изменили модель использования файловых систем и Интернета. Теперь с помощью графического интерфейса (HTTP браузера), пользователь просматривает HTML документы, хранящиеся на Web-сервере. Практически все HTTP браузеры агрегированы с FTP клиентами, с помощью, которых они могут подгружать к себе файл с нужным HTML документом.</p><p>Базовые сервисы файловых систем</p><p>Все виды файловых систем предоставляют свои пользователем обязательно следующие сервисы: управление томами, авторизацию доступа, журналирование, снимки; а сетевые - еще и синхронизацию доступа.</p><p> Управление томами</p><p>Управление томами предоставляет один из основных сервисов системы управления файловой системой. Его реализует та часть операционной системы, которая обеспечивает взаимодействие файловой системы либо системы управления базами данных с дисковой подсистемой.  Этот слой программного обеспечения агрегирует несколько жестких дисков ДПС в один виртуальный большого объёма и обеспечивает доступ к нему со стороны приложений, таких, как файловая система либо система управления базами данных. Управление томами так же может разбить виртуальный диск на несколько виртуальных дисков меньшего объёма. Это позволяет системному администратору быстро реагировать в случае изменения требований со стороны приложений. В зависимости от реализации управление томами может выполнять все функции RAID контроллера (об этом ниже) либо интеллектуальной дисковой подсистемы.  Надо только учитывать, что, когда функциональность RAID контроллера и другие сервисы, переносят в систему управления файловой системой, то это приводит к дополнительной нагрузке на центральный процессор и другие аппаратные ресурсы сервера, где располагается система управления файловой системой.</p><p>Авторизация доступа к файлам</p><p>Поскольку файловая система является общим хранилищем файлов, принадлежащих, вообще говоря, разным пользователям, системы управления файлами должны обеспечивать авторизацию доступа к файлам. Процедура авторизации заключается в проверке, что пользователь имеет права на работу с указанным им файлом и может выполнять над ним указанную пользователем операцию (чтение, запись, удаление, копирование и т.п.). В общем виде подход состоит в том, что для каждого зарегистрированного пользователя и для каждого существующего файла файловой системы указываются действия, выполнение которых над данным файлом разрешено или запрещено данному пользователю (так называемый мандатный способ защиты - у каждого пользователя должен быть мандат для работы с определенным файлом). Применение мандатного способа авторизации доступа влечет за собой существенные накладные расходы, связанные с необходимостью хранения дополнительных данных для каждого пользователя для проверки правомочности доступа.</p><p>Поэтому в большинстве современных систем управления файлами применяется упрощенный подход к авторизации доступа к файлам, традиционно поддерживаемый, например, в ОС UNIX (так называемый дискреционный подход). При использовании этого подхода с каждым зарегистрированным пользователем связывается пара целочисленных идентификаторов: идентификатор группы, к которой относится пользователь, и его собственный идентификатор. Этими же идентификаторами снабжается каждый процесс, запущенный от имени данного пользователя и имеющий возможность обращаться к системным вызовам файловой системы. Соответственно, при каждом файле хранится полный идентификатор пользователя (собственный идентификатор плюс идентификатор группы), который создал этот файл, и помечается, какие действия с файлом может производить он сам, какие действия с файлом доступны для остальных пользователей той же группы и что могут делать с файлом пользователи других групп. Для каждого файла проверяют возможность выполнения трех действий: чтение, запись и выполнение. Хранимая информация очень компактна (два целых числа для представления идентификаторов и поле из 9 бит для характеристики возможных действий), при проверке требуется относительно небольшое количество действий. Такого способа контроля доступа в большинстве случаев достаточно.</p><p> Журналирование</p><p>Журналирование - это механизм, который гарантирует целостное восстановление файловой системы, в случае ее разрушения, например, из-за отказа физического диска. Для этого система управления файлами записывает в специальный файл, называемый журналом и невидимый для пользователя или его приложения, любые изменения, сделанные в файле, до фактического внесения изменений.  В случае разрушения файловой системы на основании информации журнала происходит восстановление файлов.</p><p> Снимки</p><p>Снимки (snapshot) - аналог функции мгновенного копирования у дисковых подсистем.  Снимок фиксирует в файле специального вида состояние файловой системы в определенный момент времени. Приложение или пользователь может получить потом доступ к этому файлу. Единственно, о чем надо побеспокоиться заранее - это чтобы данные были согласованы (консистентны). Для этого служит аппарат синхронизации.</p><p>Синхронизация многопользовательского доступа</p><p>Если операционная система поддерживает многопользовательский режим либо в случае сетевой файловой системы, может возникнуть ситуация, когда два или более пользователей (процессов) одновременно пытаются работать с одним и тем же файлом. Если все эти пользователи собираются только читать файл, ничего страшного не произойдет. Но, если хотя бы один из них будет изменять файл, то для корректной работы этой группы требуются специальные действия - взаимная синхронизация.</p><p>В файловых системах взаимную синхронизацию обычно осуществляют следующим способом. В операции открытия файла (первой и обязательной операции, с которой должен начинаться сеанс работы с файлом) помимо прочих параметров указывается режим работы (чтение или изменение). Если к моменту выполнения этой операции от имени некоторого процесса A файл уже открыт некоторым другим процессом B, причем существующий режим открытия несовместим с требуемым режимом (совместимы только режимы чтения), то в зависимости от особенностей системы либо процессу A сообщается о невозможности открытия файла в нужном режиме, либо процесс A блокируют (приостанавливают) до тех пор, пока процесс B не выполнит операцию закрытия файла.</p><p>NAS - сетевое подключаемое хранилище</p><p>Постепенно с ростом масштабов компьютерных сетей файловые системы стали размещать на специальных, выделенных серверах, ориентированных на эффективную работу с файлами, например, на совместное использование одного и того же файла несколькими пользователями. Эти серверы стали называть файловыми серверами, функциональность и сервисы их ОС были ориентированы и оптимизированы под работу файловых систем.</p><p>Со временем их роль возросла настолько, что их стали рассматривать, как самостоятельный вид файловых хранилищ - сетевое подключаемое хранилище (Network Attached Storage - NAS). NAS состоит из одного или нескольких преднастроенных файловых серверов с подключенными дисковыми подсистемами. ОС этих файловых серверов оптимизированы под работу с файлами, из них удалены все функции кроме тех, которые нужны для работы с файлами.  Поэтому они быстрее обычной ОС, к NAS можно обращаться через Интернет. Кроме уже отмеченных достоинств, следует указать простоту масштабирования файловых систем, построенных на NAS хранилищах. Например, администратор файловой системы может выделить отдельное NAS хранилище для работы определенного подразделения, проекта или для большого Web-сайта. Если файловая система большого почтового сервера переполнена, администратор может подключить через сеть дополнительное NAS хранилище. Однако на этом пути надо быть осторожным, т.к. сложность и стоимость обслуживания таких систем так же быстро возрастает.</p><p>Примеры применения файлов</p><p>Чаще всего файлы используются для хранения текстовых данных: документов, текстов программ и т. д. Такие файлы обычно создаются и модифицируются с помощью различных текстовых редакторов. Эти редакторы могут быть очень простыми, такими, как ed в мире UNIX или утилиты редактирования Far Manager, WordPad и других интерактивных сред ОС Windows. Они могут быть сложными и многофункциональными, синтаксически ориентированными, как, например, GNU Emacs. Но обычно структура текстовых файлов очень проста (c точки зрения файловой системы): это либо последовательность записей, содержащих строки текста, либо последовательность байтов, среди которых встречаются специальные символы (например, символы конца строки). Конечно же, сложность логической структуры текстового файла определяется текстовым редактором, но в любом случае файловой системе она не видна.</p><p>Файлы, содержащие тексты программ, используются как входные файлы компиляторов (чтобы правильно воспринять текст программы, компилятор должен понимать логическую структуру текстового файла), которые, в свою очередь, формируют файлы, содержащие объектные модули. С точки зрения файловой системы объектные файлы также обладают очень простой структурой - последовательность записей или байтов. Система программирования накладывает на такую структуру более сложную и специфичную для этой системы логическую структуру объектного модуля. Подчеркнем, что логическая структура объектного модуля файловой системе неизвестна; эта структура поддерживается инструментами системы программирования.</p><p>Аналогично обстоит дело с файлами, формируемыми редакторами связей (редактор связей должен понимать логическую структуру файлов объектных модулей) и содержащими образы выполняемых программ. Логическая структура таких файлов остается известной только редактору связей и загрузчику - программе операционной системы. Общая схема взаимодействия программных компонентов при построении программы показана на рис. 3. Выше кратко были обозначены способы использования файлов в процессе разработки программ, но можно сказать, что ситуация аналогична и в других случаях: например, при создании и использовании файлов, содержащих графическую, аудио- и видеоинформацию.</p><p>Рис. 3. Связи между программными компонентами по пониманию логической структуры файлов</p><p>Одним словом, файловые системы обычно обеспечивают хранение слабо структурированной информации, оставляя дальнейшую структуризацию прикладным программам. В перечисленных выше случаях использования файлов это даже хорошо, потому что при разработке любой новой прикладной системы, опираясь на простые, стандартные и сравнительно дешевые средства файловой системы, можно реализовать те структуры хранения, которые наиболее точно соответствуют специфике данной прикладной области.</p><p> СУБД - Системы Управления Базами Данных</p><p>Потребности информационных систем</p><p>Типовая информационная система, главным образом, ориентирована на хранение, выбор и модификацию данных соответствующей прикладной области. Структура таких данных зачастую очень сложна, и, хотя структуры данных различны в разных информационных системах, между ними часто бывает много общего.</p><p>На начальном этапе использования вычислительной техники для построения информационных систем проблемы структуризации данных решались индивидуально в каждой информационной системе. Производились необходимые надстройки над файловыми системами (библиотеки программ), подобно тому, как это делается в компиляторах, редакторах и т. д. (рис. 4).</p><p>Рис. 4. Примитивная схема структуризации данных в информационной системе</p><p>Но поскольку для функционирования информационных систем требуются сложные структуры данных, эти дополнительные индивидуальные средства управления данными являлись существенной частью информационных систем и практически повторялись от одной системы к другой. Стремление выделить общую часть информационных систем, ответственную за управление сложно структурированными данными, явилось, одной из первых побудительных причин создания Систем Управления Базами Данных (СУБД). Очень скоро стало понятно, что невозможно обойтись общей библиотекой программ (рис. 5), реализующей над стандартной базовой файловой системой более сложные методы хранения данных.</p><p>Рис. 5. Две информационные системы с общей библиотекой</p><p>Поясним это на примере. Предположим, что требуется реализовать простую информационную систему, поддерживающую учет служащих некоторой организации. Система должна выполнять следующие действия:</p><p>выдавать списки служащих по отделам;</p><p>поддерживать возможность перевода служащего из одного отдела в другой;</p><p>обеспечивать средства поддержки приема на работу новых служащих и увольнения работающих служащих.</p><p>Кроме того, для каждого отдела должна поддерживаться возможность получения:</p><p>имени руководителя отдела;</p><p>общей численности отдела;</p><p>общей суммы заработной платы служащих отдела, среднего размера заработной платы и т. д.</p><p>Для каждого служащего должна поддерживаться возможность получения:</p><p>номера удостоверения по полному имени служащего (для простоты допустим, что имена всех служащих различны);</p><p>полного имени по номеру удостоверения;</p><p>информации о соответствии служащего занимаемой должности и о размере его заработной платы.</p><p>Структуры данных</p><p>Предположим, что мы решили основывать эту информационную систему на файловой системе и пользоваться одним файлом СЛУЖАЩИЕ, расширив базовые возможности файловой системы за счет специальной библиотеки функций. Поскольку минимальной информационной единицей в нашем случае является служащий, в этом файле должна содержаться одна запись для каждого служащего. Чтобы можно было удовлетворить указанные выше требования, запись о служащем должна иметь следующие поля:</p><p>полное имя служащего (СЛУ_ИМЯ);</p><p>номер его удостоверения (СЛУ_НОМЕР);</p><p>данные о соответствии служащего занимаемой должности (СЛУ_СТАТ; для простоты «да» или «нет», соответствует или не соответствует должности);</p><p>размер заработной платы (СЛУ_ЗАРП);</p><p>номер отдела (СЛУ_ОТД_НОМЕР).</p><p>Поскольку мы решили ограничиться одним файлом СЛУЖАЩИЕ, та же запись должна содержать имя руководителя отдела (СЛУ_ОТД_РУК). Иначе было бы невозможно, например, получить имя руководителя отдела с известным номером.</p><p>Чтобы информационная система могла эффективно выполнять свои базовые функции, необходимо обеспечить многоключевой доступ к файлу СЛУЖАЩИЕ по уникальным ключам (ключ называется уникальным, если его значения гарантированно различны во всех записях файла) СЛУ_ИМЯ и СЛУ_НОМЕР. Очевидно, что в противном случае для выполнения наиболее часто используемых операций получения данных о конкретном служащем понадобится последовательный просмотр в среднем половины записей файла.</p><p>Кроме того, должна быть обеспечена возможность эффективного выбора всех записей с общим значением СЛУ_ОТД_НОМЕР, т. е. доступ по неуникальному ключу. Если не поддерживать специальный механизм доступа, то для получения данных об отделе в целом в общем случае потребуется полный просмотр файла. Требуемая общая структура файла СЛУЖАЩИЕ показана на рис. 6. Но даже в этом случае, чтобы получить численность отдела или общий размер зарплаты, система должна будет выбрать все записи о служащих указанного отдела и посчитать соответствующие общие значения.</p><p>СЛУ_ИМЯ</p><p>СЛУ_НОМЕР</p><p>СЛУ_СТАТ</p><p>СЛУ_ЗАРП</p><p>СЛУ_ОТД_НОМЕР</p><p>СЛУ_ОТД_РУК</p><p>Рис. 6. Структура файла СЛУЖАЩИЕ на уровне приложения (случай одного файла)</p><p>Таким образом, мы видим, что при реализации даже такой простой информационной системы на базе файловой системы возникают следующие затруднения:</p><p>требуется создание достаточно сложной надстройки для многоключевого доступа к файлам;</p><p>возникает существенная избыточность данных (для каждого служащего повторяется имя руководителя его отдела);</p><p>требуется выполнение массовой выборки и вычислений для получения суммарной информации об отделах.</p><p>Кроме того, если в ходе эксплуатации системы потребуется, например, обеспечить операцию выдачи списков служащих, получающих указанную зарплату, то либо придется при выполнении каждой такой операции полностью просматривать файл, либо нужно будет реструктурировать файл СЛУЖАЩИЕ, объявляя ключевым и поле СЛУ_ЗАРП.</p><p>Для улучшения ситуации можно было бы поддерживать два многоключевых файла: СЛУЖАЩИЕ и ОТДЕЛЫ. Первый файл должен был бы содержать поля СЛУ_ИМЯ, СЛУ_НОМЕР, СЛУ_СТАТ, СЛУ_ЗАРП и СЛУ_ОТД_НОМЕР, а второй - ОТД_НОМЕР, ОТД_РУК (номер удостоверения служащего, являющегося руководителем отдела), ОТД_СЛУ_ЗАРП (общий размер зарплаты служащих данного отдела) и ОТД_РАЗМЕР (общее число служащих в отделе). Структура этих файлов показана на рис. 7.</p><p>Рис. 7. Структура файлов СЛУЖАЩИЕ и ОТДЕЛЫ на уровне приложения (случай двух файлов)</p><p>Введение этих двух файлов позволило бы преодолеть большинство неудобств, перечисленных в предыдущем абзаце. Каждый из файлов содержал бы только не дублируемую информацию, не возникала бы необходимость в динамических вычислениях суммарной информации по отделам. Но заметим, что при таком переходе наша информационная система должна обладать некоторыми новыми особенностями, сближающими ее с СУБД.</p><p>Целостность данных</p><p>Теперь система должна «знать», что она работает с двумя информационно связанными файлами, должна иметь информацию о структуре и смысле каждого поля. Например, системе должно быть известно, что у полей СЛУ_ОТД_НОМЕР в файле СЛУЖАЩИЕ и ОТД_НОМЕР в файле ОТДЕЛЫ один и тот же смысл - номер отдела.</p><p>Кроме того, система должна учитывать, что в ряде случаев изменение данных в одном файле должно автоматически вызывать модификацию второго файла, чтобы общее содержимое файлов было согласованным. Например, если на работу принимается новый служащий, то нужно добавить запись в файл СЛУЖАЩИЕ, а также должным образом изменить поля ОТД_СЛУ_ЗАРП и ОТД_РАЗМЕР в записи файла ОТДЕЛЫ, соответствующей отделу этого служащего. Более точно, система должна руководствоваться следующими правилами:</p><p>если в файле СЛУЖАЩИЕ содержится запись со значением поля СЛУ_ОТД_НОМЕР, равным n, то и в файле ОТДЕЛЫ должна содержаться запись со значением поля ОТД_НОМЕР, также равным n;</p><p>если в файле ОТДЕЛЫ содержится запись со значением поля ОТД_РУК, равным m, то и в файле СЛУЖАЩИЕ должна содержаться запись со значением поля СЛУ_НОМЕР, также равным m.</p><p>Правила (1) и (2) являются частными случаями общего правила ссылочной целостности: поле СЛУ_ОТД_НОМЕР содержит «ссылки» на записи таблицы ОТДЕЛЫ, и поле ОТД_РУК содержит «ссылки» на записи таблицы СЛУЖАЩИЕ.</p><p>Далее:</p><p>при любом корректном состоянии информационной системы значение поля ОТД_СЛУ_ЗАРП любой записи отд_k файла ОТДЕЛЫ должно быть равно сумме значений поля СЛУ_ЗАРП всех тех записей файла СЛУЖАЩИЕ, в которых значение поля СЛУ_ОТД_НОМЕР совпадает со значением поля ОТД_НОМЕР записи отд_k;</p><p>при любом корректном состоянии информационной системы значение поля ОТД_РАЗМЕР любой записи отд_k файла ОТДЕЛЫ должно быть равно числу всех тех записей файла СЛУЖАЩИЕ, в которых значение поля СЛУ_ОТД_НОМЕР совпадает со значением поля ОТД_НОМЕР записи отд_k;</p><p>Далее мы увидим, что правила (3) и (4) представляют собой примеры общих ограничений целостности базы данных.</p><p>Понятие согласованности, или целостности, данных является ключевым понятием баз данных. Фактически, если в информационной системе (даже такая простой, как в нашем примере) поддерживается согласованное хранение данных в нескольких файлах, можно говорить о том, что в ней поддерживается база данных (БД). Если же некоторая вспомогательная система управления данными позволяет работать с несколькими файлами, обеспечивая их согласованность, можно назвать ее системой управления базами данных (СУБД).</p><p>Уже только требование поддержки согласованности данных в нескольких файлах не позволяет при построении информационной системы обойтись библиотекой функций: такая система должна обладать некоторыми собственными данными (их принято называть метаданными), определяющими целостность данных. В нашем примере информационная система должна отдельно сохранять метаданные о структуре файлов СЛУЖАЩИЕ и ОТДЕЛЫ, а также правила, определяющие условия целостности данных в этих файлах (принято считать, что правила также составляют часть метаданных).</p><p>Языки запросов</p><p>Обеспечение целостности данных - это далеко не все, что обычно требуется от СУБД. Начнем с того, что даже в нашем примере пользователю информационной системы будет не слишком просто получить, например, общую численность отдела, в котором работает Петр Иванович Сидоров. Придется сначала узнать номер отдела, в котором работает указанный служащий, а затем установить численность этого отдела. Было бы гораздо проще, если бы СУБД позволяла сформулировать такой запрос на языке, более удобном для пользователей. Такие языки называются языками запросов к базам данных. Например, на языке запросов SQL наш запрос можно было бы выразить в следующей форме (запрос 1):</p><p>SELECT ОТД_РАЗМЕР   FROM СЛУЖАЩИЕ, ОТДЕЛЫ     WHERE СЛУ_ИМЯ = 'ПЕТР ИВАНОВИЧ СИДОРОВ' AND                     СЛУ_ОТД_НОМЕР = ОТД_НОМЕР;</p><p>Это пример запроса на языке SQL с «полусоединением»: c одной стороны, запрос адресуется к двум файлам - СЛУЖАЩИЕ и ОТДЕЛЫ, но с другой стороны, данные выбираются только из файла ОТДЕЛЫ. Условие СЛУ_ОТД_НОМЕР = ОТД_НОМЕР всего лишь «ограничивает» интересующий нас набор записей об отделах до одной записи, если Петр Иванович Сидоров действительно работает на данном предприятии. Если же Петр Иванович Сидоров не работает на предприятии, то условие СЛУ_ИМЯ = 'ПЕТР ИВАНОВИЧ СИДОРОВ' не будет удовлетворяться ни для одной записи файла СЛУЖАЩИЕ, и поэтому запрос выдаст пустой результат.</p><p>Возможна и другая формулировка того же запроса (запрос 2):</p><p>SELECT ОТД_РАЗМЕР</p><p>  FROM ОТДЕЛЫ</p><p>    WHERE ОТД_НОМЕР =</p><p>          (SELECT СЛУ_ОТД_НОМЕР</p><p>             FROM СЛУЖАЩИЕ</p><p>               WHERE СЛУ_ИМЯ = 'ПЕТР ИВАНОВИЧ СИДОРОВ');</p><p>Это пример запроса на языке SQL с вложенным подзапросом. Во вложенном подзапросе выбирается значение поля СЛУ_ОТД_НОМЕР из записи файла СЛУЖАЩИЕ, в которой значение поля СЛУ_ИМЯ равняется строковой константе 'ПЕТР ИВАНОВИЧ СИДОРОВ'. Если такая запись существует, то она единственная, поскольку поле СЛУ_ИМЯ является уникальным ключом файла СЛУЖАЩИЕ. Тогда результатом выполнения подзапроса будет единственное значение - номер отдела, в котором работает Петр Иванович Сидоров. Во внешнем запросе это значение будет ключом доступа к файлу ОТДЕЛЫ, и снова будет выбрана только одна запись, поскольку поле ОТД_НОМЕР является уникальным ключом файла ОТДЕЛЫ. Если же на данном предприятии Петр Иванович Сидоров не работает, то подзапрос выдаст пустой результат, и внешний запрос тоже выдаст пустой результат.</p><p>Приведенные примеры показывают, что при формулировке запроса с использованием SQL можно не задумываться о том, как будет выполняться этот запрос. Среди метаданных базы данных будет содержаться информация о том, что поле СЛУ_ИМЯ является ключевым для файла СЛУЖАЩИЕ (т. е. по заданному значению имени служащего можно быстро найти соответствующую запись или убедиться в том, что запись с таким значением поля СЛУ_ИМЯ в файле отсутствует), а поле ОТД_НОМЕР - ключевое для файла ОТДЕЛЫ (и более того, оба ключа в соответствующих файлах являются уникальными), и система сама воспользуется этим. Можно формально доказать, что формулировки запрос 1 и запрос 2 эквивалентны, т. е. вне зависимости от состояния данных всегда производят один и тот же результат. Наиболее вероятным способом выполнения запроса в обеих формулировках будет выборка записи из файла СЛУЖАЩИЕ со значением поля СЛУ_ИМЯ, равным строке 'ПЕТР ИВАНОВИЧ СИДОРОВ', взятие из этой записи значения поля СЛУ_ОТД_НОМЕР и выборка из таблицы ОТДЕЛЫ записи с таким же значением поля ОТД_НОМ.</p><p>Если же, например, возникнет потребность в получении списка сотрудников, не соответствующих занимаемой должности, то достаточно обратиться к системе с запросом (запрос 3):</p><p>SELECT СЛУ_ИМЯ, СЛУ_НОМЕР   FROM СЛУЖАЩИЕ    WHERE СЛУ_СТАТ = 'НЕТ';</p><p>и система сама выполнит необходимый полный просмотр файла СЛУЖАЩИЕ, поскольку поле СЛУ_СТАТ не является ключевым, и другого способа выполнения не существует.</p><p>Транзакции, журнализация и многопользовательский режим</p><p>Представим себе, что в первоначальной реализации информационной системы, основанной на использовании библиотек расширенных методов доступа к файлам, обрабатывается операция принятия на работу нового служащего. Следуя требованиям согласованного изменения файлов, информационная система вставляет новую запись в файл СЛУЖАЩИЕ и собирается модифицировать соответствующую запись файла ОТДЕЛЫ (или вставлять в этот файл новую запись, если служащий является первым в своем отделе), но именно в этот момент происходит (например) аварийное выключение питания компьютера.</p><p>Очевидно, что после перезапуска системы ее база данных будет находиться в рассогласованном состоянии (точно будут нарушены правила (3) и (4), а может быть, и правила (1) и (2)). Потребуется выяснить это (а для этого нужно явно проверить соответствие данных в файлах СЛУЖАЩИЕ и ОТДЕЛЫ) и привести данные в согласованное состояние. Проверку и коррекцию можно выполнить, например, следующим образом. Сгруппировать записи файла СЛУЖАЩИЕ по значениям поля СЛУ_ОТД_НОМЕР. Для каждой группы (a) проверить, существует ли в файле ОТДЕЛЫ запись, значение поля ОТД_НОМ которой равняется значению поля СЛУ_ОТД_НОМЕР записей данной группы; если такой записи в файле ОТДЕЛЫ нет, то (b) исключить группу из файла СЛУЖАЩИЕ и перейти к обработке следующей группы; иначе (c) посчитать число записей в группе и вычислить суммарное значение заработной платы; (d) обновить полученными значениями поля ОТД_РАЗМЕР и ОТД_СЛУ_ЗАРП соответствующей записи файла ОТДЕЛЫ и перейти к обработке следующей группы.</p><p>Настоящие СУБД берут такую работу на себя, поддерживая транзакционное управление и журнализацию изменений базы данных. Прикладная система не обязана заботиться о поддержке корректности состояния базы данных, хотя и должна знать, какие цепочки операций изменения данных являются допустимыми.</p><p>Представим теперь, что в информационной системе требуется обеспечить параллельную (например, многотерминальную) работу с базой данных служащих и отделов. Если опираться только на использование файлов, то для обеспечения корректности на все время модификации любого из двух файлов доступ других пользователей к этому файлу будет блокирован (вспомните возможности файловых систем в отношении синхронизации параллельного доступа). Таким образом, зачисление на работу Петра Ивановича Сидорова существенно затормозит получение информации о служащем Иване Сидоровиче Петрове, даже если они работают в разных отделах. Настоящие СУБД обеспечивают гораздо более тонкую синхронизацию параллельного доступа к данным.</p><p> Основные функции и компоненты СУБД</p><p>До сих пор мы не вычленяли СУБД из состава информационной системы, имея в виду общую организацию системы, подобную той, которая показана на рис. 8.</p><p>Рис. 8. СУБД в составе информационной системы</p><p>СУБД как независимый системный компонент</p><p>Здесь видны два дефекта. Во-первых, очевидно, что СУБД должна поддерживать достаточно развитую функциональность. Повторять эту функциональность в каждой информационной системе неразумно. С другой стороны, неясно, каким образом можно обеспечить готовый к использованию компонент СУБД, который можно было бы встраивать в информационные системы.</p><p>[w:footnoteReference]</p><p>* Во-вторых, уже должно быть понятно, что набор файлов можно назвать базой данных только при наличии метаданных. На рис. 8 метаданные являются принадлежностью информационной системы, и поэтому, например, файлы СЛУЖАЩИЕ и ОТДЕЛЫ можно эффективно использовать только через нашу гипотетическую систему регистрации служащих.</p><p>Предположим, что предприятию нужна еще и информационная бухгалтерская система. Очевидно, что для ее работы также потребуются данные о служащих и отделах. При показанной выше организации системы возможны два варианта выполнения задачи, ни один из которых не является удовлетворительным.</p><p>Теоретически можно «внедрить» бухгалтерскую систему в состав системы регистрации сотрудников. Но ведь, как правило, бухгалтерские системы покупаются в виде готовых и отдельных продуктов, не приспособленных к подобному «внедрению».</p><p>Можно скопировать метаданные системы регистрации служащих в бухгалтерскую систему. Но метаданные (как и данные) не обязательно являются статичными. Структура базы данных может со временем изменяться, могут исчезать одни правила целостности и появляться другие. Как согласовывать копии метаданных, поддерживаемые независимыми информационными системами? Так мы приходим к организации системы, показанной на рис. 9.</p><p>Рис. 9. Отдельная СУБД и базы данных с метаданными</p><p>Здесь мы видим три информационные системы, которые через одну СУБД работают с двумя разными базами данных, причем первая и вторая системы работают с общей базой данных. Это возможно, поскольку метаданные каждой базы данных содержатся в самих базах данных, и достаточно лишь указать СУБД, с какой базой данных желает работать данное приложение. Поскольку СУБД функционирует отдельно от приложений, и ее работа с базами данных регулируется метаданными, совместное использование одной базы данных двумя информационными системами не вызовет потери согласованности данных, и доступ к данным будет должным образом синхронизироваться. Заметим, что рис. 9 вплотную приближает нас к наиболее распространенной в последние десятилетия архитектуре «клиент-сервер». СУБД играет роль «сервера», обсуживающего нескольких «клиентов» - прикладных информационных систем.</p><p>Функции СУБД</p><p>Ранее мы выявили несколько потребностей информационных систем, которые не покрываются возможностями систем управления файлами: поддержка логически согласованного набора файлов; восстановление согласованного состояния данных после разного рода сбоев; обеспечение высокого уровня параллелизма работы нескольких пользователей; поддержка языка манипулирования данными. Эти и другие функции традиционно поддерживаются СУБД. В этом подразделе мы обсудим функции СУБД подробнее.</p><p>Непосредственное управление данными во внешней памяти</p><p>Эта функция обеспечивает поддержку необходимых структур внешней памяти как для хранения данных и метаданных, непосредственно входящих в БД, так и для служебных целей, например, для убыстрения доступа к данным в некоторых случаях (обычно для этого используются индексы). В некоторых реализациях СУБД активно используются возможности существующих файловых систем, в других работа производится на уровне устройств внешней памяти. Но развитых СУБД пользователи в любом случае не обязаны знать, использует ли СУБД файловую систему, и, если использует, то как организованы файлы. В частности, в СУБД обычно поддерживается собственная система именования объектов БД.</p><p>Управление буферами основной памяти</p><p>СУБД обычно работают с БД значительного размера; по крайней мере, этот размер обычно существенно больше объема доступной основной памяти. Понятно, что если при обращении к любому элементу данных будет производиться обмен с внешней памятью, то вся система будет работать со скоростью устройства внешней памяти. Практически единственным способом реального увеличения этой скорости является буферизация данных в основной памяти. Даже если операционная система производит общесистемную буферизацию данных (как, например, в случае ОС UNIX), этого недостаточно для целей СУБД, которая располагает гораздо большей информацией о полезности буферизации той или иной части БД. Поэтому в развитых СУБД поддерживается собственный набор буферов основной памяти с использованием собственной дисциплиной замены буферов.</p><p>Управление транзакциями</p><p>Транзакция - это последовательность операций над БД, рассматриваемых СУБД как неделимое целое. Либо транзакция успешно выполняется, и СУБД фиксирует (выполняет операцию COMMIT) изменения БД, произведенные этой транзакцией, во внешней памяти, либо ни одно из этих изменений никак не отражается на состоянии БД. Понятие транзакции необходимо для поддержания логической целостности БД. Если вспомнить наш пример информационной системы с файлами СЛУЖАЩИЕ и ОТДЕЛЫ, то единственным способом не нарушить целостность БД при выполнении операции приема на работу нового служащего является объединение элементарных операций над файлами СЛУЖАЩИЕ и ОТДЕЛЫ в одну транзакцию. Таким образом, поддержание механизма транзакций является обязательным условием даже однопользовательских. Но понятие транзакции гораздо более важно в многопользовательских СУБД.</p><p>То, что каждая транзакция начинается при целостном состоянии БД и оставляет это состояние целостным после своего завершения, делает очень удобным использование понятия транзакции как единицы активности пользователя по отношению к БД. При соответствующем управлении посредством СУБД параллельно выполняемыми транзакциями каждый пользователь может в принципе ощущать себя единственным пользователем СУБД (на самом деле, это несколько идеализированное представление, поскольку в некоторых случаях пользователи многопользовательских СУБД могут ощутить присутствие своих коллег).</p><p>С управлением транзакциями в многопользовательской СУБД связаны важные понятия сериализации транзакций. Под сериализацией параллельно выполняемых транзакций понимается такой порядок планирования выполнения операций, при котором суммарный эффект смеси транзакций эквивалентен эффекту их некоторого последовательного выполнения. Понятно, что если удается добиться действительно сериального выполнения смеси транзакций, то для каждого пользователя, по инициативе которого образована транзакция, присутствие других транзакций будет незаметно (если не считать некоторого замедления работы по сравнению с однопользовательским режимом).</p><p>Существует несколько базовых алгоритмов сериализации транзакций. Наиболее распространены алгоритмы, основанные на синхронизационных блокировках объектов БД. При использовании любого алгоритма сериализации возможны конфликты между двумя или более транзакциями по доступу к объектам БД. В этом случае для поддержки сериализации необходимо выполнить откат (ликвидировать все изменения, произведенные в БД) одной или более транзакций. Это один из случаев, когда пользователь многопользовательской СУБД может реально (и достаточно неприятно) ощутить присутствие в системе транзакций других пользователей.</p><p>Журнализация</p><p>Одним из основных требований к СУБД является надежность хранения данных во внешней памяти. Под надежностью хранения понимается то, что СУБД должна быть в состоянии восстановить последнее согласованное состояние БД после любого аппаратного или программного сбоя. Обычно рассматриваются два возможных вида аппаратных сбоев: так называемые мягкие сбои, которые можно трактовать как внезапную остановку работы компьютера (например, аварийное выключение питания), и жесткие сбои, характеризуемые потерей информации на носителях внешней памяти. Примерами программных сбоев могут быть аварийное завершение работы СУБД (по причине ошибки в программе или в результате некоторого аппаратного сбоя) или аварийное завершение пользовательской программы, в результате чего некоторая транзакция остается незавершенной. Первую ситуацию можно рассматривать как особый вид мягкого аппаратного сбоя; при возникновении последней требуется ликвидировать последствия только одной транзакции.</p><p>Понятно, что в любом случае для восстановления БД нужно располагать некоторой дополнительной информацией. Другими словами, для обеспечения надежного хранения данных в БД требуется хранение избыточных данных, причем та часть данных, которая используется для восстановления БД, должна храниться особо надежно. Наиболее распространенным методом поддержания такой избыточной информации является ведение журнала изменений БД.</p><p>Журнал - это особая часть БД, недоступная пользователям СУБД и поддерживаемая с особой тщательностью (например, можно поддерживать две копии журнала, располагаемые на разных физических дисках), в которую поступают записи обо всех изменениях основной части БД. В разных СУБД изменения БД журнализуются на разных уровнях: иногда запись в журнале соответствует некоторой логической операции изменения БД (например, операции удаления строки из таблицы реляционной БД), иногда - минимальной внутренней операции модификации страницы внешней памяти; в некоторых системах одновременно используются оба подхода.</p><p>Во всех случаях принято придерживаться стратегии «упреждающей» записи в журнал (так называемого протокола Write Ahead Log - WAL). Грубо говоря, эта стратегия заключается в том, что запись об изменении любого объекта БД должна попасть во внешнюю память журнала раньше, чем измененный объект попадет во внешнюю память основной части БД. Известно, что если в СУБД корректно соблюдается протокол WAL, то с помощью журнала можно решить все проблемы восстановления БД после любого сбоя.</p><p>Поддержка языков БД</p><p>Для работы с базами данных используются специальные языки, в целом называемые языками баз данных. В ранних СУБД поддерживалось несколько специализированных по своим функциям языков. Чаще всего выделялись два языка - язык определения схемы БД (SDL - Schema Definition Language) и язык манипулирования данными (DML - Data Manipulation Language). SDL служил, главным образом, для определения логической структуры БД, т.е. той структуры БД, какой она представляется пользователям. DML содержал набор операторов манипулирования данными, т.е. операторов, позволяющих заносить данные в БД, удалять, модифицировать или выбирать существующие данные. Более подробно языки ранних СУБД мы рассмотрим в следующей главе.</p><p>В современных СУБД обычно поддерживается единый интегрированный язык, содержащий все необходимые средства для работы с БД, начиная от ее создания, и обеспечивающий базовый пользовательский интерфейс с базами данных. Стандартным языком наиболее распространенных в настоящее время реляционных СУБД является язык SQL (Standard Query Language). В нескольких главах этой книги язык SQL будет рассматриваться достаточно подробно, а пока мы перечислим основные функции реляционной СУБД, поддерживаемые на «языковом» уровне (т.е. функции, поддерживаемые при реализации интерфейса SQL).</p><p>Прежде всего, язык SQL сочетает средства SDL и DML, т.е. позволяет определять схему реляционной БД и манипулировать данными. При этом именование объектов БД (для реляционной БД - в основном, именование таблиц и их столбцов) поддерживается на языковом уровне в том смысле, что компилятор языка SQL производит преобразование имен объектов в их внутренние идентификаторы на основании специально поддерживаемых служебных таблиц-каталогов. Внутренняя часть СУБД (ядро) вообще не работает с именами таблиц и их столбцов.</p><p>Язык SQL содержит специальные средства определения ограничений целостности БД. Опять же, ограничения целостности хранятся в специальных таблицах-каталогах, и обеспечение контроля целостности БД производится на языковом уровне, т.е. при первичной обработке операторов модификации БД компилятор SQL на основании имеющихся в БД ограничений целостности генерирует соответствующий программный код.</p><p>Специальные операторы языка SQL позволяют определять так называемые представления БД, фактически являющиеся хранимыми в БД запросами (результатом любого запроса к реляционной БД является таблица) с именованными столбцами. Для пользователя представление является такой же таблицей, как любая базовая таблица, хранимая в БД, но с помощью представлений можно ограничить или наоборот расширить видимость БД для конкретного пользователя. Поддержание представлений производится также на языковом уровне.</p><p>Наконец, авторизация доступа к объектам БД производится также на основе специального набора операторов SQL. Идея состоит в том, что для выполнения операторов SQL разного вида пользователь должен обладать различными полномочиями. Пользователь, создавший таблицу БД, обладает полным набором полномочий для работы с этой таблицей. В число этих полномочий входит полномочие на передачу всех или части полномочий другим пользователям, включая полномочие на передачу полномочий. Полномочия пользователей описываются в специальных таблицах-каталогах, контроль полномочий поддерживается на языковом уровне.</p><p>Имена, истории, артефакты</p><p>История СУБД началась 1960-е гг., когда были созданы первые навигационные СУБД, основанные на иерархической, сетевой и других ранних моделях данных. В этих СУБД отсутствовали развитые декларативные языки баз данных (доступ к данным явно специфицировался разработчиками информационных систем), имелись ограниченные возможности поддержки целостности баз данных и т.д. Наиболее известными СУБД этого времени, используемыми и в наше время, являются иерархическая СУБД IMS (IBM) и сетевая СУБД IDMS (Computer Associates).</p><p>В конце 1960-х, начале 1970-х гг. Эдгар Кодд (Edgar F. Codd) предложил новый подход к организации баз данных и СУБД, получивший название реляционного подхода. Для проверки практической жизнеспособности этого подхода в 1970-е гг. были выполнены экспериментальные проекты System R в IBM и Ingres в Калифорнийском университете в Беркли. В этих проектах были заложены основы технологий, которые использовались в будущих коммерческих реляционных СУБД (появился язык SQL, были разработаны принципы оптимизации запросов, методы управления транзакциями и т.д.).</p><p>В 1980-е гг. появились первые коммерческие реляционные СУБД (IBM DB2, Oracle и т.д.). В течение этого десятилетия за счет совершенствования технологии удалось добиться эффективности реляционных СУБД, не уступающей эффективности ранних СУБД, при обеспечении существенно более развитой среды разработки информационных систем. К концу 1980-х гг. SQL-ориентированные системы стали главенствовать на рынке СУБД. Одновременно с этим, появилось направление объектно-ориентированных СУБД (O2, ObjectStore, Versant и т.д.), направленное на преодоление разрыва между системами типов данных традиционных языков программирования и системами типов, поддерживаемыми в базах данных реляционными СУБД. Кроме того, возникло направление объектно-реляционных СУБД (Illustra), которое преследовало те же цели, что и объектно-ориентированные СУБД, но без отказа от реляционной парадигмы.</p><p>1990-е гг. ознаменовались появлением ряда развитых универсальных SQL-ориентированных СУБД с объектно-реляционными возможностями (Informix Universal Server, Oracle8, DB2 Universal Database). В СУБД появились возможности определения пользовательских типов данных, методов, функций и процедур. В конце десятилетия был принят стандарт SQL:1999, в котором эти возможности, а также все основные средства SQL-ориентированных СУБД были окончательно согласованы и утверждены. В это же время продолжали развиваться объектно-ориентированные СУБД, и был принят ряд стандартов объектно-ориентированной модели данных, но к концу десятилетия объектно-реляционные СУБД в основном вытеснили объектно-ориентированные СУБД с рынка. Появились достаточно конкурентоспособные бесплатно доступные СУБД с открытыми исходными кодами (MySQL, PostgreSQL и т.д.).</p><p>В начале 21-го века Майкл Стоунбрейкер (Michael Stonebraker) провозгласил и обосновал конец эпохи универсальных СУБД и переход к набору технологий специализированных СУБД, ориентированных на поддержку отдельных классов приложений баз данных (информационных систем). Появились специализированные XML-ориентированные СУБД (Tamino, Sedna и т.д.), потоковые СУБД (Streambase и т.д.), аналитические СУБД (Vertica, Greenplum и т.д.), транзакционные СУБД (VoltDB и т.д.). Обострилась проблема взрывообразного роста данных (BigData), что сделало чрезвычайно актуальной технологию горизонтально масштабируемых СУБД и информационных систем: это нашло свое отражение в том, что практически все современные СУБД являются массивно-параллельными. Та же проблема BigData привела к появлению ряда систем категории NoSQL, разработчики которых опираются на опыт области распределенных систем и не следуют канонам традиционных СУБД.</p><p>В СССР и России в разное время имелось несколько оригинальных разработок СУБД, в частности, ИНЕС и НИКА (1980-е гг., ИСА РАН), ЛИНТЕР (компания РЕЛЭКС, Воронеж, начиная с 1990-х гг.), Sedna (2000-е гг., ИСП РАН). Отечественные разработчики входили и входят в международные сообщества, разрабатывающие СУБД с открытыми исходными кодами.</p><p>Возможная классификация СУБД</p><p>СУБД можно классифицировать в соответствии с разными критериями, например, следующим образом:</p><p>по модели данных, на которой основывается СУБД. Таким образом СУБД можно подразделить на сетевые, иерархические, реляционные (и SQL-ориентированные), объектно-ориентированные, XML-ориентированные и т.д.</p><p>по степени универсальности - СУБД (Oracle, DB2, Microsoft SQL Server и т.д.) и специализированные (Vertica, VoltDB и т.д.). Универсальные СУБД направлены на поддержку приложений (информационных систем всех возможных видов) и расширяются по мере возрастания потребностей информационных систем. Специализированные СУБД ориентированы на эффективную поддержку одного класса информационных систем (например, транзакционных или аналитических систем).</p><p>на файл-серверные, клиент-серверные и встраиваемые СУБД. В файл-серверных СУБД (Informix SE, Microsoft Access и т.д.) базы данных хранятся в файлах специализированого файлового сервера, а экземпляры СУБД работают на каждой клиентской рабочей станции, синхронизуясь по доступу к общим данным на уровне файлов.</p><p>В клиент-серверных СУБД (Oracle, DB2, PostgreSQL и т.д.) все основные компоненты СУБД выполняются на отдельном сервере, на котором хранится и база данных, - сервере базы данных. На клиентской рабочей станции находится интерфейсная (клиентская) часть СУБД и выполняется код приложения (если не используется трехзвенная архитектура с выделенным сервером приложений). Клиент-серверные СУБД - традиционная основа корпоративных информационных систем.</p><p>Наконец, встраиваемые СУБД (BerkeleyDB, SQlite и т.д.) встраиваются в код приложений (информационных систем) и полностью выполняется на том же компьютере и даже в том же процессе. Встраиваемые СУБД успешно применяются в Интернет- и мобильных приложениях.</p><p>На СУБД, хранящие данные во внешней памяти, и СУБД, сохраняющие данные в основной памяти (in-memory). Исторически подавляющее большинство СУБД хранит базы данных в дисковой памяти. На этот способ хранения рассчитаны многие важные компоненты СУБД, начиная от буферизации данных в основной памяти и заканчивая оптимизатором запросов.</p><p>Для обеспечения очень быстрого доступа к базам данных по чтению in-memory СУБД располагают всю базу данных в основной памяти. В некоторых вариантах таких СУБД (например, TimesTen) основная копия базы данных содержится в дисковой памяти, и измененные части базы данных записываются на диск. В других вариантах (например, VoltDB) дисковая память вообще не используется; такие системы работают в распределенной среде, и надежность хранения данных обеспечивается за счет поддержки их копий (репликации) в разных узлах системы.</p><p>На однопроцессорные, параллельные с общей памятью, параллельные с общими дисками и параллельными без использования общих ресурсов СУБД. Однопроцессорные СУБД не используют аппаратные возможности параллелизма и выполняются на одном процессоре (в частности, на одном одноядерном процессоре). До появления многоядерных процессоров такие СУБД были распространены, поскольку многопроцессорные компьютеры с общей памятью были слишком дороги и малодоступны.</p><p>Параллельные СУБД с общей памятью (Oracle, DB2 и т.д.) поддерживались ведущими компаниями с 1980-х гг., но стали массово распространенными только после появления многоядерных процессоров. Параллельные СУБД этого класса обеспечивают межзапросный или внутризапросный параллелизм с использованием нескольких ядер. Наличие общей памяти позволяет избежать пересылок данных, но требует применения сложной синхронизации.</p><p>В параллельных СУБД с общими дисками (Oracle RAC) несколько экземпляров СУБД работают в разных узлах вычислительного кластера, но все эти экземпляры обращаются к общей дисковой подсистеме, в которой хранится база данных. Исторически эта архитектура происходит от файл-серверной архитектуры, но используется для обеспечения межзапросного или внутризапросного параллелизма.</p><p>Наконец, в параллельных СУБД без использования общих ресурсов (Vertica, Greenplum и т.д.) несколько экземпляров СУБД работают в разных узлах кластера каждый со своим разделом базы данных. Каждый запрос декомпозируется на части, адресуемые к соответствующему разделу и обрабатываемые в соответствующем узле. Полученные частичные результаты объединяются за счет обмена сообщениями между узлами. Архитектура параллельной аналитической СУБД без общих ресурсов обеспечивает горизонтальное масштабирование при росте объема данных и наиболее подходит для решения проблемы BigData в области аналитики.</p><p>Перспективы развития, нерешенные проблемы</p><p>Практически все современные СУБД ориентированы на хранение баз данных на жестких дисках с подвижными головками. Именно в расчете на использование этого вида внешних носителей оптимизированы индексные структуры, используемые для сокращения времени выполнения операций над базами данных, да и все алгоритмы, используемые для обработки различных операций.</p><p>Однако в XXI веке появилась и стремительно совершенствуется технологий так называемых твердотельных дисков (solid state disks, SSD), основанных на использовании флэш-памяти. Устройства SSD лишены механических компонентов, в них нет подвижных магнитных головок и вращающихся магнитных поверхностей. Учитывая то, что время чтения блока из устройства SSD примерно в 10 раз меньше соответствующего времени для дисков с подвижными головками (hard disks, HD), а также то, что доступная емкость SSD приближается к емкости HD, возникает естественное желание заменить HD на SSD как базовых устройств хранения данных для СУБД.</p><p>Однако это совсем не просто, поскольку требует массовой переделки сложных и объемных компонентов СУБД, которые совершенствовались десятилетиями в расчете на использование HD. Поэтому производители СУБД к настоящему времени не решились пойти на такой ответственный шаг и пытаются использовать SSD совместно с HD в основном для кэширования баз данных. Так что разработка новых СУБД, с самого начала ориентированных на использование SSD, - это вызов второго десятилетия XXI века, который рано или поздно должен быть принят разработчиками СУБД.</p><p>При всех своих преимуществах флэш-память остается внешней памятью. Для доступа к ней требуется выполнение специальных действий к контроллерами SSD, а обмены выполняются блоками данных, как и с HD. Более серьезный вызов представляет появление энергонезависимой основной памяти (Non-volatile random-access memory, NVRAM). К 2016 г. разработано несколько вариантов такой памяти с различной физической природой. Все их объединяет потенциальная возможность использования вместо традиционной основной памяти при сохранении содержимого после отключения питания.</p><p>Компьютер, оснащенный такой памятью, теоретически не будет нуждаться в устройствах внешней памяти для долговременного хранения данных. Если скорость и стоимость NVRAM будут сопоставимы с соответствующими показателями традиционной основной памяти, это откроет возможность разработки нового поколения СУБД, у которых скорость выполнения операций и выборки, и изменения баз данных будет не меньше скорости выборки данных у имеющихся in-memory СУБД.</p><p>Потребуются новые подходы к управлению транзакциями, обеспечению надежности хранения данных и т.д. Фактически, нужно будет пересмотреть сложившуюся архитектуру СУБД. Думаю, что это будет сделано, но, скорее всего, следует считать это вызовом третьего десятилетия XXI века, хотя, возможно, события будут развиваться гораздо быстрее.</p><p>Развитие аппаратных и программных средств управления внешней памятью диктовалось потребностями информационных систем, для построения которых требовалась возможность надежного долговременного хранения больших объемов данных, а также обеспечение достаточно быстрого доступа к этим данным.</p><p>Системы управления файлами во внешней памяти обеспечивают минимальные потребности информационных систем, предоставляя средства распределения и структуризации дисковой памяти, именования файлов, авторизации доступа и поддержки многопользовательского режима. По мере развития технологии информационных систем их потребности возрастают, выходя за пределы возможностей, обеспечиваемых файловыми системами.</p><p>На примере тривиальной информационной системы были показаны ситуации, в которых возможности файловых систем явно недостаточны. Более того, попытки расширения возможностей файловой системы путем включения в приложение дополнительных программных компонентов во многих случаях не приводят к успеху. В пределе такие попытки могут привести к появлению самостоятельного программного продукта, обладающего некоторыми чертами СУБД. Однако настоящие СУБД являются настолько большими и сложными программными системами, что вероятность успешного создания «самодельной» СУБД ничтожно мала.</p><p>Еще один вывод заключается в том, что при выборе технологии построения информационной системы нужно тщательно оценивать и прогнозировать ее потенциальные потребности в средствах управления данными. Конечно, любую информационную систему можно основывать на использовании промышленной, большой и мощной СУБД. Но вполне может оказаться так, что в действительности приложение будет использовать доли процентов общих возможностей СУБД. Накладные расходы (затраты на дополнительную аппаратуру, лицензирование дорогостоящего программного продукта, увеличение общего времени выполнения операций) могут оказаться неоправданными.</p><p>6</p><p>[w:sdt]</p><p>II.5.6 Облачные вычисления и центры обработки данных</p><p>Центры Обработки Данных</p><p>Быстрое распространение Интернета, Всемирной Паутина (WWW), системы обмена сообщениями (мессенджеры), возникновение социальных сетей предъявили новые требования к организации вычислений для поддержки услуг.  Пользователи стали требовать, чтобы услуги всегда были доступны там, где они нуждаются в них. Поток запросов на услуги не равномерен. Например, по данным компании Facebook на 2010 г. среднее число пользователей, одновременно находившихся в системе Facebook, оценивалось в 25 млн. человек, разбросанных по всему Земному шару. Однако в пике их число в разы превышало эту среднюю оценку и падало до нескольких тысяч в ночное время. Обслуживание таких запросов требовало умения масштабировать вычислительные мощности, выделяемые сервису, в зависимости от потока запросов к нему, умения динамически перераспределять вычислительные мощности в зависимости, например, от времени суток и географического положения пользователей (где-то день, а где-то ночь).</p><p>	Клиент-серверная архитектура, которая активно развивалась в 80-е и 90-е годы не удовлетворяла этим требованиям. В ней каждое приложение жестко было привязано к конкретному вычислителю (серверу), мощность которого была ограничена и быстро увеличить ее, или как еще говорят, масштабировать, не останавливая работу вычислителя, не представлялось возможным. Решением проблемы масштабирования стали центры обработки данных, соединенные быстрыми каналами связи (часто беспроводными) с пользователями, и облачные вычисления.</p><p>Центр обработки данных (ЦОД) генерирует поток услуг по запросу пользователей. Внешне ЦОД часто похож на невзрачное здание, похожее на склад, не неся при этом никаких признаков того, что находится внутри. Внутри гул вентиляторов, охлаждающих стойки с компьютерами. Каждая стойка размера с бытовой холодильник образует кластер. Кластеры вплетены в «кружево» из электрических и оптических кабелей, которые образуют сеть, соединяющую компьютеры в кластер, кластеры между собой и с внешним миром. Например, у компании Google в шести ЦОД'ах, разбросанных по всем континентам, работает более 500 млн. серверов.</p><p>Каждый кластер является однородным в том смысле, что все сервера одинаковы как по архитектуре, так и по скорости. Эти тысячи серверов используются для распределенной, параллельной обработки запросов на уровне процессов специального вида, так называемых, нитей (threads). Каждый запрос представляет собой задачу, которая разбивается на подзадачи. Процесс может охватывать как все подзадачи одного запроса, так и лишь одну конкретную подзадачу. Все задачи и подзадачи выполняются параллельно на одном и том же сервере, либо на разных серверах. Обработка заканчивается, когда выполнены все подзадачи одного запроса. При такой организации обработки, максимальное время выполнения одной подзадачи будет определять время всей задачи, т.е. реакции на запрос пользователя.</p><p>Даже при массовом параллелизме, когда число серверов достигает десятков и сотен тысяч, на уровне процессов накладные расходы на их взаимодействие через сеть и стек протоколов взаимодействия, т.е. программы реализующие протоколы сетевого взаимодействия, могут существенно ограничить общую производительность приложения из-за эффекта закона Амдала. Таким образом, архитектура ЦОД и архитектура программного приложения определяют то насколько эффективно будет работать приложение.</p><p>Способ использования кластера имеет определяющее влияние на соблюдение требований к сервисам (Service Level Agreement - SLA) и, в конечном итоге, на производительность приложения. Кроме ЦОД есть другой вид высокопроизводительных вычислителей - массивно параллельные суперкомпьютеры (НРС- High Performance Computer), состоящие из тысяч компьютеров, работающих параллельно. Высокопроизводительные вычислители НРС основаны на быстрой и эффективной системе межкомпьютерных соединений, которая обеспечивала высокую скорость передачи небольших порций данных - сообщений. Кластер может быть использован в выделенном режиме только одним приложением, либо режиме разделения несколькими приложениями. Приложения для HPC обычно используют кластер в выделенном режиме, чтобы избежать конкуренцию за ресурсы между несколькими приложениями.  Эта конкуренция требует специальных механизмов урегулирования, и всегда влияет на производительность приложений. Поэтому YHC системы не применяют там, где потоки запросов динамично меняются, что типично для таких сервисов как социальные сети, Web-сервисы, поисковики.</p><p>С другой стороны, многие Web приложения используют сервисы от множества других кластеров, на которых, с целью повышения общей загруженности ресурсов всей системы, могут одновременно работать несколько приложений. Поэтому в ЦОД, как в системе кластеров, используют виртуализацию и масштабирование для изоляции приложений как по производительности, так и с целью отсутствия взаимного влияния от ошибок.</p><p>Под Web-приложения, такие как поисковики, электронная почта, и совместная работа с документами планируют ресурсы и запускают в кластере. Приложения, имеющие интерфейс с пользователем, работают в режиме мягкого времени - у них есть с десяток миллисекунд для ответа на запрос пользователя. Выполнение запроса распределяется между несколькими рабочими процессами в кластере. Рабочие процессы генерируют частные ответы, которые агрегируют и отправляют пользователю.</p><p>Если часть рабочих процессов не заканчивает свою работу своевременно, например, из-за перегрузки в сети, то задержка может превысить допустимый порог. Это приведет к тому, что результаты некоторых рабочих процессов не будут агрегированы с результатами остальных рабочих процессов, что приведет к пустой трате вычислительных и сетевых ресурсов и может не благоприятно сказаться на финальном результате.</p><p>Для того, чтобы уменьшить вероятность перегрузки, сеть может быть overprovisioned, т.е. сетевых ресурсов может быть запрошено по максимуму, чтобы гарантированно обеспечить достаточную пропускную способность для даже самых экзотических моделей трафика. Overprovisioning в рамках крупномасштабных сетей ЦОД является крайне дорогим приемом.</p><p>Другой подход состоит в реализации нескольких политик обеспечения качества сервисов (QoS - Quality of Service), ориентированных на различные классы трафиков. Трафики разных классов для обеспечения гарантированной производительности изолируют друг от друга, применяя разные техники трафик инжиниринга.  Такой подход позволяет гарантировать требования SLA для приложений. Большинство политик обеспечения QoS реализуются с помощью оборудования коммутаторов и NIC (сетевого интерфейса), где трафик разделяют на основе приоритетов, явно указанных, в виде меток маршрутизаторов или хостов, или неявно заданных через диапазон портов коммутатора. Цель одна - обеспечить высокопроизводительную сеть с предсказуемой задержкой и пропускной способностью для разнообразных типов трафика.</p><p>Облачные вычисления (Cloud Computing)</p><p>Облачные вычисления - технология распределённой обработки данных, в которой вычислительные, сетевые и ресурсы хранения предоставляются пользователю как сервис. Чаще всего пользователю не надо иметь компьютер. Ему нужен сервис по обработке данных, доступу к информации, возможности посмотреть в графическом виде результаты расчетов и т.д.</p><p>Физической инфраструктурой для облачных вычислений является ЦОД. Пользователь не знает, да, ему и не нужно знать, на каких конкретных физических ресурсах и где расположен тот ЦОД, на ресурсах которого реализован сервис, которым он пользуется в данный момент. Причем предоставление пользователю услуг, как сервис, является ключевым. Здесь можно провести прямую аналогию с электричеством. Когда мы втыкаем вилку в розетку мы не задумываемся где расположен источник электроэнергии, которую мы получаем из розетки. В случае облачных вычислений ситуация аналогична, мы обращаемся за вычислительными услугами, ресурсами т.д., при этом нам безразлично где физически располагается источник услуг или соответствующий ресурс. Волшебство облака заключается в том, что его услуги доступны всегда и везде.</p><p>Существуют три основных режима предоставления облачных сервисов: Infrastructure-As-A-Service, Platform-As-A-Service и Software-As-A-Service. В настоящее время существует широкая таксономия терминов, сужающих контекст, например, MBaaS (Mobile-Backend-As-A-Service) и Metal-As-Service, VNFaaS, NFVIaaS, но в общем смысле все сводится к этим трем.</p><p>В режиме Infrastructure-As-A-Service (IaaS) пользователь получает виртуальную инфраструктуру: набор виртуальных машин нужной производительности, виртуальных каналов связи, соединяющих нужным пользователю образом его виртуальные машины, виртуальные хранилища данных (виртуальные диски), нужного пользователю объема. Установка приложений на эти виртуальные машины, политики маршрутизации данных в виртуальной сети и т.д. - это все возлагается на самого пользователя.</p><p>В режиме Platform-As-A-Service (PaaS) облако предоставляет пользователям группу услуг, которые позволяют им абстрагироваться от инфраструктуры приложений, операционной системы, промежуточного ПО, а также предоставляет группам разработчиков способность получать ресурсы, разрабатывать, собирать, тестировать и разворачивать свои приложения без помощи ИТ-специалистов. PaaS упрощает развертывание приложений при помощи самообслуживания, инструментов, выделяемых по требованию, ресурсов, автоматизации и контейнера среды выполнения, размещенного на платформе. Это устраняет необходимость в средствах развертывания, а разработчикам больше не потребуется заниматься настройкой и при каждой смене фазы жизненного цикла приложения и ждать, пока физические серверы или виртуальные машины скопируют файлы из одной среды в другую. Например, предоставление доступа к такой системе как 1С в режиме PaaS означает, что пользователь не заботиться об инфраструктуре, необходимой для работы этой платформы, а сосредоточен лишь на настройке этой системы под свои нужды и повседневной эксплуатации настроенной системы, т.е. поддержке актуальности, сохранности и безопасности данных, формировании нужных отчетов и форм и т.п.</p><p>В режиме SaaS программное обеспечение как услуга (также software on demand - программное обеспечение по требованию) - бизнес-модель продажи и использования программного обеспечения, при которой пользователь получает доступ к нужному приложению через Интернет. Например, если нужно поработать с текстом, то сам текстовый редактор нам не нужен.  Нужен сервис по набору и редактированию текстов, их верстке, а не само программное обеспечение, которое реализует эти услуги. Поэтому выгоднее и проще арендовать на время нужное программное обеспечение, а все проблемы, связанные с обеспечением этого приложения нужными ресурсами, его работоспособностью, надежным функционированием и т.п., оставить тому, кто владеет этим приложением.</p><p>Важно заметить, что эти три режима предоставления сервисов могут существовать отдельно или в комбинации друг с другом: предложения типа SaaS необязательно могут быть разработаны над предложениями PaaS, так как решения, основанные на использовании PaaS, часто предоставляются как SaaS, предложения же типа PaaS - больше, чем просто работающая на IaaS платформа. Симбиоз трех методов поставки облачных сервисов, разумеется, должен предваряться серьезным анализом и часто целым переосмыслением архитектуры сервиса, который должен работать в облаке.</p><p>Основной технологией, давшей стимул в развитии облачных вычислений, является виртуализация. Под термином виртуализация понимают технику динамического создания логического объекта, функционально эквивалентного соответствующему физическому ресурсу. Например, виртуальная вычислительная машина - это программная имитация с помощью специального программного обеспечения аппаратных ресурсов компьютера: процессор, память, жесткий диск, и т.д. Далее, на такую виртуальную машину можно установить операционную систему, и она будет на нем работать точно так же, как и на простом, «железном» компьютере. Самое интересное достоинство этой технологии - это возможность запуска нескольких виртуальных машин внутри одного «железного» компьютера, при этом все виртуальные машины могут работать независимо друг от друга точно так же как несколько разных программ работают на одном и том же физическом компьютере.-</p><p>Технология виртуализации повышает эффективность использования вычислительных и сетевых ресурсов благодаря возможности быстро развернуть несколько виртуальных объектов вместо одного физического или переместить, или, как говорят, мигрировать виртуальный объект на другой физический. Например, виртуализация позволяет развернуть несколько виртуальных машин на одном физическом процессоре, сопоставить несколько виртуальных каналов передачи данных одному и тому же физическому каналу и т.п. То есть там, где раньше требовалось несколько серверов - теперь можно поставить один сервер, и запустить нужное число гостевых ОС в виртуальной среде.- Возможности современных систем виртуализации позволили достигнуть существенного прогресса в плане масштабирования, отказоустойчивости, различных видов оптимизаций.</p><p>Физические сервера, на которых запускаются виртуальные машины, могут быть объединены в кластер, и в случае отказа одного из серверов - автоматически мигрировать на другой. Полной отказоустойчивости добиться не всегда возможно, но возможные простои сильно сократятся: миграция занимает несколько минут, тогда как ремонт или замена самого сервера может занять часы, а то и дни.</p><p>Термин «облако» приобрел известность где-то вначале 2000-х. Однако все технологии, которые сегодня входят в состав облачной парадигмы, существовали и раньше, однако на рынке не было предложений, которые бы объединяли перспективные технологии в едином коммерчески привлекательном решении. Начиная с где-то с 2010-го появились публичные облачные сервисы, благодаря которым эти технологии стали, с одной стороны, доступны широкой публике, а с другой - их экономика стала понятна для бизнеса.</p><p>Концепции проектов, которые можно считать прародителями привычных нам «облачных» сервисов, появились в 80-х годах прошлого века. Именно тогда разработчики программного обеспечения предложили такую модель приложений, где все вычисления и обработка информации осуществляются не на компьютере пользователя, а на удаленных серверах, соединенных локально с компьютером пользователя. Глобальной сети Интернет в то время не существовало, поэтому первые идеи «облаков» оказались трудно реализуемыми и практически не использовались при создании новых программ.</p><p>Как уже было сказано, одной из наиболее существенных технологических новаций, лежащих в основе облачных вычислений, являются технологии виртуализации. Впервые виртуализация была предложена в середине 1960-х годов применительно к основной памяти компьютера. Тогда были придуманы и реализованы механизмы виртуализации памяти (см. раздел Вычислители).</p><p>Следующими важнейшими вехами в истории концепции облачных вычислений стало заявление Джона МакКарти, компьютерный исследователь, известный своими разработками (создатель термина "Artificial Intelligence" и языка программирования Lisp), о том, что "вычислительные мощности могут когда-нибудь стать публично доступными ресурсами", и выпуск в 1966 году книги Дугласа Пархилла "The Challenge of the Computer Utility", в которой он описал практически все основные характеристики существующих сегодня облаков, а также впервые употребив сравнение с электрической сетью.</p><p>Первой компанией, в полной мере, осознавшей коммерческую перспективу общедоступных технологий виртуализации, стала компания Amazon. В 2006 году компания представила своим клиентам разветвленную систему веб-сервисов. Принципиальное отличие новой инфраструктуры состояло в том, что пользователи получали в распоряжение не только ресурсы для хранения данных, но и вычислительные мощности серверов, принадлежащих Amazon. Хороший пример оказался заразительным - буквально через год похожие услуги предложили флагманы IT-индустрии: Google, Sun и IBM.</p><p>Основное отличие «облачного» программного решения от обычного в том, что вся информация, с которой Вы работаете, сохраняется не на Вашем жестком диске, а на удаленном сервере. Аналогично с производимыми операциями: они нагружают не персональный компьютер или ноутбук, а мощности серверов компании, предоставляющей то или иное приложение. Вы же получаете лишь результат, отправляемый на монитор через интернет.</p>